=== Event driven systems: Using the Event Timer

==== Introduction

Many processes in nature are described as 'event driven': something that happens when an evolving condition reaches some state. For example, in arid environments, reproduction may be episodic with organisms remaining dormant for many years until significant rainfall occurs; an epidemic may occur when a population reaches a certain density or bushfires might be triggered from natural or anthropogenic sources.

The previous tutorials have used a clock timer to drive the simulation dynamics. In essence, a clock timer simply issues regular time events autonomously, at intervals determined by its properties â€“ its time step. 
An event timer, on the other hand, is not autonomous. It drives its child processes through events posted from somewhere else for some time in the future. That 'somewhere else' entails other functions that determine when those circumstances have arisen.

In this tutorial, based on Tutorial 4, we show how to drive disturbance from the state of the modelled community. We will create an event timer to drive the disturbance effects process and post events in the future to its queue from the community growth function. The time an event is triggered is not necessarily the time the event effects take place. For example, population density might be sufficient to set an epidemic in train, but there may be a delay before significant mortality takes place, by which time the original triggering conditions may have changed. In other words, cause and effect are not necessarily simultaneous. Thus, a decision has to be made as to whether or not 2 events that trigger the same process makes sense. IF two events are identical in type and time then the new one is rejected. Otherwise, if two events are equal in type but scheduled for different times, the one nearest the head of the queue is kept and the other rejected.

*FLAWS*: Is all this crap?? Should duplicate events be allowed: duplicate as in type rather than time? I think what has to happen is if 2 events are equal then remove the event furthest from the queue head. What equal means is this: time events have an optional bitset for flags and an  payload object. If both are the same (including nulls) then they're equal. What we do with the bitset and payload apart from this i'm not sure. In Firescape, the payload was a cell object where the ignition or propagation was to take place - so it was passed to the process to decide what to do with this. If you agree this should be the approach, then it means passing time event payload and bitset in generated code. So in the case here, bitset and payload are null so 'time' determines what to do and the queue will only retain one event at a time. All this worked in Firescape with weather update events, fire perimeter updates and ignition events. But does it make general sense? Not sure. I guess duplicate events are allowed if the source is exogenous to the process. For example you have have as many ignitions for the same place as you like because they will have no effect if the cell is already burning. Likewise if a disturbance causes community mortality, its ok to have multitple events if the source of the events was not the current state of the community.


I don't know - bit of a mess.

As the frequency of disturbance will now be an emergent property of the growth of the community, we no longer need to prescribe this and can remove the associated constant and process. 

There can be any number of event timers in a specification and each timer can be driven by any number of functions posting events at any time in the future. This design allows specifying very complex causal chains.

==== Specifications

. Create a new project from on `Tutorials -> 3 I.D.H` and name it 'Tut5'.

. Collapse all sub-trees to the root and expand `dataDefinition:dDef` and `system:sys1` sub-trees.

. Collapse `structure:struc1` to `system:sys1` and re-apply the layout.

Delete the nodes that are no longer required.

[start = 4]

. Right-click on `timer:clock1` and select `Delete tree -> process:procDistOccurrence`.

. Delete the node `field:freq`.

Create the new event timer and reassign the associated process.

[start = 6]

. Create a `timer` as child of `timeline:tmln1`, name it 'event1' and select `EventTimer` as its class.

. Right-click on `timer:clock1` and select `Delete child edge -> process:procDistEffects`.

. Right-click on `timer:event1` and select `New child edge -> process:procDistEffects`.

Set a process to post events to the event timer.

[start = 9]

. Right-click again on `timer:event1` and select `New edge -> fedBy -> function:CommGrowth`.

It only remains to modify the java code of `function:CommGrowth` to post a time event to the timer's queue. You can do this by either pasting the following code into the function's snippet or create a Java project and add the code there.




[source, Java]
------------------------

------------------------

==== Next

The next tutorial introduces managing random number streams.

