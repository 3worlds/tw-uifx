=== Tutorial 4: Elaborating the model structure: Testing the Intermediate Disturbance Hypothesis

==== Introduction

In this tutorial we add a disturbance to effect a community of species modelled with the competitive Lotka-Volterra equation (CLV) from Tutorial 3. This model could be used to examine the Intermediate Disturbance Hypothesis (IDH: <<Connell1978, Connell, 1978>>). 

==== Specifications

Begin this tutorial using the Lotka-Volterra specifications from the `Tutorials` menu as a starting point.

. Create a new project from `Tutorials -> 2 LotkaVolterra` and name it 'Tut4'.

===== Data definition

Data can play one of three _roles_ in the _3Worlds archetype_:

... _constants_ (cnsts), 

... _drivers_ (drvs) or 

... _decorators_ (decs). 

Thus far we have only made use of data as _drivers_ and _constants_. The third role, _Decorators_, are values derived in some way from the other two. Importantly, they are re-initialised at the beginning of each time step. In this tutorial we add a species diversity index as a  _decorator_, derived from relative abundance of each species.

. Collapse all nodes except for the `dataDefinition` sub-tree, hide the _cross-links_ ('*X*'), and re-apply the layout ('*L*').

. Add a new `record` as a child of `dataDefinition:dDef` and name it 'decs'.

. Add a `field` as a child of `record:decs`, name it 'div' (diversity index) of type `Double`.

As noted previously, these names are just for clarity - they don't impose their roles as _drivers_, _constants_ or _decorators_. You can name a node any thing you like as long as the names are unique. Here, the records are named to indicate their intended roles to keep things organised. Their role will later be formally defined by a relationship with a `category` which we create when building the `structure` specifications. While building the data definition, expect task messages to accumulate until these roles have been defined.

We now define some data for the simple disturbance model: frequency and intensity.

[start = 4]

. Add a new `record` to `dataDefinition:dDef` and name it 'distCnsts' (disturbance constants).

. Add two fields to this record, both of type `Double` called 'freq' and 'inten' respectively. 

The records carried over from the previous tutorial should now be given better names. A trick with the Tree layout functions is that they order the trees alphabetically. To arrange nodes so that related nodes of a particular role are close together, prefix the name with the same string - in this case 'dist'. We should also prefix all the data associated with the CLV with 'comm' (community).

[start = 6]

. Rename `record:cnsts` to `record:commCnsts`, `record:drvs` to `record:commDrvs` and `record:decs` to `record:commDecs`.

. Re-apply the layout and the nodes should now be arranged in a more sensible order.

Fill out the meta-data properties with at least the description and range of the data as this information will be incorporated in the comments of the generated Java code (i.e. add the optional property `description` to the new data nodes).

[start = 8]

. Add the following descriptions to the new data definitions properties:

- `freq#description`: 'average return time'
- `inten#description:` '% population decrease'
- `div#description:` 'Shannon's diversity index'

For simplicity, we define intensity as a constant rather than a driver.

[#fig-tut4-data-definition]
.The data definition sub-tree for Tutorial 4. Tree layout algorithms sort nodes in alphabetical order. Keeping this in mind when naming nodes can help keep your specifications in a particular order.
image::tutorial4IMG/fig-tut4-data-definition.png[align="center"]

That's all the data needed for this tutorial. We can now specify the system dynamics.

===== Dynamics

In this section we add two additional functions: one to initiate a disturbance and a second to apply the disturbance to the community.

. Collapse the `dataDefinition` sub-tree and expand `system:community`.

. Create a `process` as child of `timer:clock1` and name it 'p1DistOcc`.

. Create a `function` as child of `process:p1DistOcc` and name it 'DistOcc' and set its type as `RelateToDecision`.

. Create a second `process` as child of `timer:clock1` and name it 'p2DistEffectComm'.

. Create a `function` as child of `process:p2DistEffectComm`, name it 'DistEffectComm' and set its type to `ChangeOtherState`.

The name the growth process and function should now be changed to something more appropriate:

[start = 6]

. Rename `process:p1` to `process:p3CommGrowth`.

. Rename `function:Growth` to `function:CommGrowth`.

The function `function:CommGrowth` will perform the same task as it did in the previous tutorial: calculate the next state of _x_ from its current state. 

The function `function:DistOcc`, a `RelateToDecision` function, will decide if a disturbance is to occur or not. If it returns _true_, a relation will be formed between the, yet to be specified, disturbance and community categories. 

If a disturbance occurs, `function:DistEffectComm` will implement the consequences of the disturbance on the community.

This implies an order of execution of these three functions. As all these functions are driven by the same `timer` and therefore occur simultaneously, it means we must make the calling order explicit. To do this we add a `dependsOn` edge between the relevant processes.

First, show the _cross-links_ and set `process:p2DistEffectComm` to depend on `process:p1DistOcc`.

[start=8]
. Show the _cross-links_ (*X*).

. Right-click on `process:p2DistEffectComm` and select `New edge -> dependsOn -> process:p1DistOcc`.

To force the disturbance effects to take place _before_ the community growth, make `process:p3CommGrowth` depend on `process:p2DistEffectComm`.

[start = 10]

. Right-click on `process:p3CommGrowth` and select `New edge -> dependsOn -> process:p2DistEffectComm`.

After re-applying the layout (assuming a Tree layout is in use), it's clear why these process names were prefixed by p1, p2 and p3.

At this time, `dataTracker:trk1` is set to track `system.sys`. There will be no global data to track in this model as there was in the previous Lotki-Volterra so we should remove this edge.

[start = 11]

. Right-click on `dataTracker:trk` and select 'Delete edge -> trackComponent ->system.community'.

[#fig-tut4-dynamics]
.The system dynamics sub-tree for Tutorial 4. .
image::tutorial4IMG/fig-tut4-dynamics.png[align="center"]

That's all that's required in this section. The task list indicates that the new processes must belong to some categories. To do that we need to move on to the structure of the specifications.

===== Structure

Recall from the previous tutorial, that `system:sys1` is acting as a single component. It's _role_ was defined as:

... _permanent_;

... _atomic_; 

... belonging to the _arena_; 

... accessing particular data from the `dataDefinition` sub-tree; and,

... has `process:p1` applied to it.



The _arena_ is a special category. It must exist in every specification. Any data associated with it (_constants_, _drivers_ and _decorators_) is available to all `functions`: the data is global. The system (`system:sys1`) was also being tracked by the data tracker. This relationship was removed above because 'x', the population being tracked, will now be part of a category related to the community component of the model i.e 'x' will no longer be global data.

The _role_ of a `component` is defined by its `componentType`. We'll need two `ComponentTypes`; one for the community (the CLV equation) and one for the disturbance. We also need a `relationType` to define the association between the disturbance and the effected community.

Because of the new stucture we will now specifiy, the name 'community' for the 'system' node will be misleading. In the Lotka-Volterra model, the system node was the only structure required and so 'community' was a reasonable choice. For now though we should rename this node to its default: 'sys1'.

. Right-click on 'system.community` and rename it `sys1`.

. Right-click on 'system.sys1` and collapse the `dynamics:sim` sub-tree.

. Create a `structure` as child of `system:sys1`.

. Create a `componentType` as a child of `structure:struc1` and name it 'distType'.

. Create a `component` as child of `componentType:distType` and name it 'dist'.

. Create a second `componentType` as child of `structure:struc1` and name it 'commType'.

. Create a `component` as child of `componentType:commType` and name it 'comm'.

. Create a `relationType` as child of `structure:struc1` and name it 'distEffectComm'.

Before proceeding to the definition of the _roles_ of these component types, we should redefine the _role_ of `system:sys1` that we inherited from Tutorial 3 when starting this project.

`system:sys1`, in aliasing as a `componentType`, must now be redefined as an `assemblage` with no functions or data associated with it. 

//First, arrange the graph display so only relevant parts are displayed. These instructions are as tedious to write as they are to follow, but its worth it.

//[start = 7]

//. Collapse all nodes to the root node.

//. Expand all nodes from the root node.

//. Collapse `experiment:expt` and `userInterface:gui` sub-trees to the root.

//. Collapse `dimensioner:nspp` to `dataDefinition:dDef`.

//. If you want, you can collapse all `fields` and `tables` into their respective tables.

//. Collapse `record:AVPopulation` and `record:AVEphemeral` to `predefined:*categories*`.

//. Collapse `category:*group*`, `category:*space*`, `category:*relation*` and `category:*lifecycle*` to `categorySet:*systemElements*`.

//. Collapse `dynamics:sim1` from `system.sys1`.

//. Re-apply the layout.

Redefine the _role_ of `system:sys1` as an `assemblage`.

[start = 8]

. Right-click on `system:sys1` and select `Delete edge -> belongsTo -> category:*atomic*`.

. Right-click again on `system:sys1` and select `New edge -> belongsTo -> category:*assemblage*`.

Remove the data associated with the _arena_.

[start = 10]
. Right-click on the root node (`3worlds:Tut4'), expand the `predefined:*categories*` and re-apply the layout. 

. Right-click on `category:*arena*` and select `Delete edge -> drivers -> record:commDrvs`.

. Right-click again on  `category:*arena*` and select `Delete edge -> constants -> record:commCnsts`.

`system:sys` is now defined as simply a _permanent assemblage_ belonging to the _arena_.

Now define a `categorySet` to partition data between the disturbance and community. Category sets contain mutually exclusive categories: something can belong to one or the other but not both. Since disturbance and community is all there is in this model, this is the 'world' of the model so this seems a reasonable name for this set of categories i.e the 'world' comprises a community and a disturbance category: something can belong to one or other of these but not both. 

[start = 13]

. Create a `categorySet` as child of `structure:struc1` and name it 'world'.

. Create a `category` as child of `categorySet:world` and name it 'distCat'.

. Create another `category` as child of `categorySet:world` and name it 'commCat'.

Define the data for these new categories.

[start = 16]

. Right-click on `category:commCat` and create the following edges:

... `drivers -> record:commDrvs`.

... `constants -> record:commCnsts`.

... `decorators -> record:commDecs`.

. Right-click on `category:commDist` and select `New edge -> constants -> record:distCnsts`.


Now define the _roles_ of the new component types for the community and disturbance. Both belong to the  _permanent_, _atomic_, and _component_ categories and accesses data through their respective categories.

[start = 18]

. Right-click on `componentType:commType` and create `belongsTo` edges to `category:*permanent*`,`category:*atomic*`,`category:*component*` and `category:commCat`. 

. Right-click on `componentType:distType` and create `belongsTo` edges to `category:*permanent*`,`category:*atomic*`,`category:*component*` and `category:distCat`. 

Now define the relation between disturbance and the community.

[start = 20]

. Create a realtionType as a child of `structure:struc1'.

. Right-click on `relationType:distEffectComm` and create edges:

... `fromCategory -> distCat`.

... `toCategory -> commCat`.

Finally, add initialisation functions for the disturbance and community component types:

[start = 22]

. Create an `initFunction` as child of `componentType:commType` and name it 'InitComm'.

. Create an `initFunction` as child of `componentType:distType` and name it 'InitDist'.

. Delete `initFunction:Init`. This was carried over from Tutorial 3 as its no longer needed.

This is also an initialisation function associated with the `system:sys1` node. This is left over from the previous Lotka-Volterra model and can be deleted.

[start = 25]

. Right-click on `system:sys1` and select 'Delete tree ->initFunction:Init1'.

[#fig-tut4-structure]
.The structure sub-tree for Tutorial 4. .
image::tutorial4IMG/fig-tut4-structure.png[align="center"]

That's all that is required in this section. To finish up, we now need to connect various sub-trees of the graph to each other. Foremost among these is to associate processes with the new structure.

===== Relations between sub-trees

Currently, `process:p3CommGrowth` is applied to `category:*arena*`. We want re-apply this process to `category:commCat`.

. Expand `dynamics:sim1` from `system:sys1`.

. Expand `predefined:*categories*` from the root node and re-apply the layout.

. Show _cross-links_ (*X*).

. Delete the `appliesTo` edge between `process:p3CommGrowth` and `category:*arena*` and re-apply it by creating an `appliesTo` edge to `category:commCat`.

The task list now has three tasks: one about the data tracker and two to connect both disturbance processes to either a `category` or a `relationType`.

[start = 5]

. Create `appliesTo` edges from both `process:procDistEffects` and `process:procDistOccurrence` to `relationType:distEffectComm`.

[start = 6]

The population _x_ is now part of the `commCat` category. 

. Create a `trackComponent` edge from `dataTracker:trk1` to `component:comm`.


We also need to track the species diversity index 'div'. 


. Create a `trackField` edge from `dataTracker:trk1` to `field:div`.


The simulation can now be run but, of course, we have yet to add code to the various functions. Here, we'll just add code snippets but if you prefer, you can create a java project and add the code there instead.

===== Java code

. Add a `snippet` to each of the three`functions` and two `initFunctions` in the specifications. Add the following code to the `JavaCode` property of each snippet:

`function:InitComm`:

[source,Java]
-----------------
double initFreq = 1.0 / x.size();
focalDrv.x.fillWith(initFreq);
for (int i = 0; i < r.size(0); i++) {
	focalCnt.r.setByInt(random.nextDouble(), i);
	focalCnt.K.setByInt(5.0 + initFreq + random.nextDouble(), i);
	for (int j = 0; j < alpha.size(1); j++) {
		if (i == j)
			focalCnt.alpha.setByInt(1.0, i, j);
		else
			focalCnt.alpha.setByInt(max(0.0001, random.nextDouble()), i, j);
	}
}
-----------------


`function:InitDist`:

[source, Java]
-----------------
focalCnt.freq = 5 + random.nextInt(50);
focalCnt.inten = random.nextDouble()*100;
-----------------

`function:CommGrowth`:
[source, Java]
-----------------
// growth
double[] dxdt = new double[x.size(0)];
for (int i = 0; i < x.size(0); i++) {
	double sum = 0;
	for (int j = 0; j < alpha.size(1); j++)
		sum += alpha.getByInt(i, j) * x.getByInt(j);
	dxdt[i] = r.getByInt(i) * x.getByInt(i) * (1 - sum / K.getByInt(i));
}
for (int i = 0; i < dxdt.length; i++)
	focalDrv.x.setByInt(Math.max(x.getByInt(i) + dxdt[i] * dt, 0.0), i);

// compute diversity
double xtot = 0.0;
for (int i = 0; i < focalDrv.x.size(0); i++)
	xtot += focalDrv.x.getByInt(i);
focalDec.div = 0.0;
for (int i = 0; i < focalDrv.x.size(0); i++)
	if (focalDrv.x.getByInt(i) > 0.0)
		focalDec.div -= (focalDrv.x.getByInt(i) / xtot) * log(focalDrv.x.getByInt(i) / xtot);

-----------------

`function:DistOccurrence`:
[source, Java]
--------------------
double proba = 1.0 / freq;
if (random.nextDouble() < proba)
	return true;
else
	return false;

--------------------

`function:DistEffectsComm`:
[source, Java]
---------------------
		for (int i = 0; i < other_x.size(); i++)
			if (other_x.getByInt(i) > other_K.getByInt(i) * inten / 100000.0)
				otherDrv.x.setByInt(otherDrv.x.getByInt(i) * other_K.getByInt(i) * inten / 100000.0, i);
---------------------


==== Next

The next tutorial introduces the event timer to drive disturbance.
