=== Tutorial 4: Elaborating the model structure: Testing the Intermediate Disturbance Hypothesis

==== Introduction

In this tutorial we add a disturbance to effect a community of species modelled with the competitive Lotka-Volterra equation (CLV) from Tutorial 3. This model could then be used to examine the Intermediate Disturbance Hypothesis (IDH: <<Connell1978, Connell, 1978>>). 

==== Specifications

Begin this tutorial using the Lotka-Volterra specifications from the `Tutorials` menu as a starting point.

. Create a new project from `Tutorials -> 2 LotkaVolterra` and name it 'Tut4'.

As the tutorial title suggests, we will be _elaborating_ the model structure. The Lotka-Volterra model has the simplest of structures: so simple that its `System` node can be named `community`. In the model we are developing here, this name would be misleading since we will have not only a 'community' but also a 'disturbance' (i.e. the system node will no longer be 'atomic' but an 'assemblage'). Therefore it will be clearer if we change the name of the system node back to its bland default: `sys1`.

[start = 2]

. Right-click on `system:community` and rename 'community' to the default name 'sys1'.


===== Data definition

Data can play one of three _roles_ in the _3Worlds archetype_; as:

... _constants_, 
... _drivers_, or
... _decorators_. 

Thus far we have only made use of data as _drivers_ and _constants_. The third role, _decorators_, are values derived in some way from the other two. Importantly, they are re-initialised at the beginning of each time step. A species diversity index will be necessary and is be one such case being derived from relative abundance of each species ('x[]').

. Collapse all nodes except for the `dataDefinition` sub-tree, hide the _cross-links_ ('*X*'), and re-apply the layout ('*L*').

. Add a new `record` as a child of `dataDefinition:dDef` and name it 'decs'.

. Add a `field` as a child of `record:decs`, name it 'div' (diversity index) of type `Double`.

As noted previously, these names are just for clarity - they don't impose their roles as _drivers_, _constants_ or _decorators_. You can name a node any thing you like as long as the names are unique. Here, the records are named to indicate their intended roles just for clarity. Their role will later be formally defined by a relationship with a `category` which we create when building the `structure` specifications. 

While building the data definition, expect task messages to accumulate until these roles have been defined.

We now define some data for the simple disturbance model: frequency and intensity.

[start = 4]

. Add a new `record` to `dataDefinition:dDef` and name it 'distCnsts' (disturbance constants).

. Add two fields to this record, both of type `Double` called 'freq' and 'inten' respectively. 

The records carried over from the previous tutorial should now be given better names. A trick with the Tree layout functions is that they order the trees alphabetically. To arrange nodes so that related nodes of a particular role are close together, prefix the name with the same string - in this case 'dist'. We should also prefix all the data associated with the CLV with 'comm' (community).

NOTE: Tree layout algorithms order nodes in alphabetical order. Consider this behaviour when choosing node names. 

[start = 6]

. Rename `record:cnsts` to `record:commCnsts`, `record:drvs` to `record:commDrvs` and `record:decs` to `record:commDecs`.

. Re-apply the layout and the nodes should now be arranged in a more sensible order.

Fill out the meta-data properties with at least the description and range of the data as this information will be incorporated in the comments of the generated Java code (i.e. add the optional property `description` to the new data nodes).

[start = 8]

. Add the following descriptions to the new data definitions properties:

- `freq#description`: 'average return time'
- `inten#description:` '% population decrease'
- `div#description:` 'Shannon's diversity index'

For simplicity, we define intensity as a constant rather than a driver.

[#fig-tut4-data-definition]
.The data definition sub-tree for Tutorial 4. Tree layout algorithms sort nodes in alphabetical order. Keeping this in mind when naming nodes can help keep your specifications in useful order.
image::tutorial4IMG/fig-tut4-data-definition.png[align="center",role="thumb"]

To display an xy plot of diversity by time since disturbance, we can add a driver to the commDrvs record to record this.

[start = 9]
. Create a `field` of type `Double` as a child of `record:commDrvs` and name it 'tsd'. Add the `description` property and enter 'Time since disturbance' for the property value.

That's all the data needed for this model. We can now specify the system dynamics.

===== Dynamics

In this section we add two additional functions: one to initiate a disturbance and a second to apply the disturbance to the community.

Before proceeding, some explanations are required to make sense of the following steps. Ignoring `dataTrackers` for the moment, a `process` can have one or more `functions`. However, the relationships (_cross_links_) between the model's dynamics, data and structure are defined at the level of `processes` not `functions`. If we don't care what order the functions are called in, and they all apply to the same data and structural elements, then we need only one process to contain all the functions. However, this is not the case here. The three functions: community growth, disturbance occurrence, and disturbance effects, must have access to different data, components and component relationships. Specifically, whether or not a disturbance is to occur depends only on disturbance data (in this model). Also order is important: it must come before disturbance effects are applied to the community. The disturbance effects applies to a relationship: that of the disturbance and the community. The growth of the community only depends on community data (the Lotka-Volterra equation). In addition, we make the decision (in this model) that the disturbance can only occur after the growth of the community, mimicking a late growing season disturbance.

// NOTE ABOUT THIS: for relateToDecision function: must be the only one type of function in its process

We will prefix the names of `processes` in such a way that the layout algorithm will place them in execution order. 

. Collapse the `dataDefinition` sub-tree and expand `system:sys1`.

. Create a `process` as child of `timer:clock1` and name it 'p1DistOcc`.

. Create a `function` as child of `process:p1DistOcc` and name it 'DistOcc' and set its type as `RelateToDecision`.

. Create a second `process` as child of `timer:clock1` and name it 'p2DistEffectComm'.

. Create a `function` as child of `process:p2DistEffectComm`, name it 'DistEffectComm' and set its type to `ChangeOtherState`.

The name the growth process and function should now be changed to something more appropriate:

[start = 6]

. Rename `process:p1` to `process:p3CommGrowth`.

. Rename `function:Growth` to `function:CommGrowth`.

The function `function:CommGrowth` will perform the same task as it did in the previous tutorial: calculate the next state of _x_ from its current state. At the same time we can calculate the diversity index and increment a counter to record the time since the last disturbance.

The function `function:DistOcc`, a `RelateToDecision` function, will decide if a disturbance is to occur or not. If it returns _true_, a relation will be formed between the, yet to be specified, disturbance and community categories. 

If a disturbance occurs, `function:DistEffectComm` will implement the consequences of the disturbance on the community.

This implies an order of execution of these three functions. As all these functions are driven by the same `timer` and therefore occur simultaneously, it means we must make the calling order explicit. To do this we add a `dependsOn` edge between the relevant processes.

First, show the _cross-links_ and set `process:p2DistEffectComm` to depend on `process:p1DistOcc`.

[start=8]
. Show the _cross-links_ (*X*).

. Right-click on `process:p2DistEffectComm` and select `New edge -> dependsOn -> process:p1DistOcc`.

To force the disturbance effects to take place _before_ the community growth (i.e. a late growing season disturbance), make `process:p3CommGrowth` depend on `process:p2DistEffectComm`.

[start = 10]

. Right-click on `process:p3CommGrowth` and select `New edge -> dependsOn -> process:p2DistEffectComm`.

After re-applying the layout (assuming a Tree layout is in use), it's clear why these process names were prefixed by p1, p2 and p3.

At this time, `dataTracker:trk1` is set to track `system.sys1`. There will be no global data to track in this model as there was in the previous Lotki-Volterra so we should remove this edge.

[start = 11]

. Right-click on `dataTracker:trk` and select `Delete edge -> trackComponent ->system.sys1`.

[#fig-tut4-dynamics]
.The system dynamics sub-tree for Tutorial 4. .
image::tutorial4IMG/fig-tut4-dynamics.png[align="center",role="thumb"]

That's all that's required in this section. The task list indicates that the new processes must belong to some categories. To do that we need to move on to the structure of the specifications.

===== Structure

Recall from the previous tutorial, that `system:sys1` is acting as a single component. It's _role_ was defined as:

... _permanent_;

... _atomic_; 

... belonging to the _arena_; 

... accessing particular data from the `dataDefinition` sub-tree; and,

... has `process:p1` applied to it.

The _arena_ is a special category. It must exist in every specification. Any data associated with it (_constants_, _drivers_ and _decorators_) is available to all `functions`: the data is global. The system (`system:sys1`) was also being tracked by the data tracker. This relationship was removed above because 'x', the population being tracked, will now be part of a category related to the community component of the model i.e 'x' will no longer be global data.

The _role_ of a `component` is defined by its `componentType`. We'll need two `ComponentTypes`; one for the community (the CLV equation) and one for the disturbance. We also need a `relationType` to define the association between the disturbance and the effected community.

. Right-click on `system.sys1` and collapse the `dynamics:sim` sub-tree.

. Create a `structure` as child of `system:sys1`.

. Create a `componentType` as a child of `structure:struc1` and name it 'distType'.

. Create a `component` as child of `componentType:distType` and name it 'dist'.

. Create a second `componentType` as child of `structure:struc1` and name it 'commType'.

. Create a `component` as child of `componentType:commType` and name it 'comm'.

. Create a `relationType` as child of `structure:struc1` and name it 'distEffectComm'.

Before proceeding to the definition of the _roles_ of these component types, we should redefine the _role_ of `system:sys1` that we inherited from Tutorial 3 when starting this project.

The node `system:sys1`, in aliasing as a `componentType`, must now be redefined as an `assemblage` with no functions or data associated with it. 

Redefine the _role_ of `system:sys1` as an `assemblage`.

[start = 8]

. Right-click on `system:sys1` and select `Delete edge -> belongsTo -> category:*atomic*`.

. Right-click again on `system:sys1` and select `New edge -> belongsTo -> category:*assemblage*`.

Remove the data associated with the _arena_.

[start = 10]
. Right-click on the root node (`3worlds:Tut4`), expand the `predefined:*categories*` and re-apply the layout. 

. Right-click on `category:*arena*` and select `Delete edge -> drivers -> record:commDrvs`.

. Right-click again on  `category:*arena*` and select `Delete edge -> constants -> record:commCnsts`.

The node `system:sys` is now defined as simply a _permanent assemblage_ belonging to the _arena_.

Now define a `categorySet` to partition data between the disturbance and community. Category sets contain mutually exclusive categories: something can belong to one or the other but not both. Since disturbance and community is all there is in this model, this is the 'world' of the model so this seems a reasonable name for this set of categories i.e the 'world' comprises a community and a disturbance category: something can belong to one or other of these but not both. 

[start = 13]

. Create a `categorySet` as child of `structure:struc1` and name it 'world'.

. Create a `category` as child of `categorySet:world` and name it 'distCat'.

. Create another `category` as child of `categorySet:world` and name it 'commCat'.

Define the data for these new categories.

[start = 16]

. Right-click on `category:commCat` and create the following edges:

... `drivers -> record:commDrvs`.

... `constants -> record:commCnsts`.

... `decorators -> record:commDecs`.

. Right-click on `category:commDist` and select `New edge -> constants -> record:distCnsts`.


Now define the _roles_ of the new component types for the community and disturbance. Both belong to the  _permanent_, _atomic_, and _component_ categories and accesses data through their respective categories.

[start = 18]

. Right-click on `componentType:commType` and create `belongsTo` edges to `category:*permanent*`,`category:*atomic*`,`category:*component*` and `category:commCat`. 

. Right-click on `componentType:distType` and create `belongsTo` edges to `category:*permanent*`,`category:*atomic*`,`category:*component*` and `category:distCat`. 

Now define the relation between disturbance and the community.

[start = 20]

. Create a realtionType as a child of `structure:struc1`.

. Right-click on `relationType:distEffectComm` and create edges:

... `fromCategory -> distCat`.

... `toCategory -> commCat`.

Finally, add initialisation functions for the disturbance and community component types:

[start = 22]

. Create an `initFunction` as child of `componentType:commType` and name it 'InitComm'.

. Create an `initFunction` as child of `componentType:distType` and name it 'InitDist'.

There is also an initialisation function associated with the `system:sys1` node. This was left over from the previous Lotka-Volterra model and can be deleted.

[start = 24]

. Right-click on `system:sys1` and select 'Delete tree ->initFunction:Init1'.

[#fig-tut4-structure]
.The structure sub-tree for Tutorial 4. .
image::tutorial4IMG/fig-tut4-structure.png[align="center",role="thumb",width=800]

That's all that is required in this section. To finish up, we now need to connect various sub-trees of the graph to each other. Foremost among these is to associate processes with the new structure.

===== Relations between sub-trees

Currently, `process:p3CommGrowth` is applied to `category:*arena*`. We want re-apply this process to `category:commCat`.

. Expand `dynamics:sim1` from `system:sys1`.

. Expand `predefined:*categories*` from the root node and re-apply the layout.

. Show _cross-links_ (*X*).

. Delete the `appliesTo` edge between `process:p3CommGrowth` and `category:*arena*` and re-apply it by creating an `appliesTo` edge to `category:commCat`.

The task list now has three tasks: one about the data tracker and two asking to connect both disturbance processes to either a `category` or a `relationType`.

[start = 5]

. Create `appliesTo` edges from both `process:procDistEffects` and `process:procDistOccurrence` to `relationType:distEffectComm`.

[start = 6]

The population _x_ is now part of the `commCat` category. 

. Create a `trackComponent` edge from `dataTracker:trk1` to `component:comm`.


We also need to track the species diversity index 'div'. 


. Create a `trackField` edge from `dataTracker:trk1` to `field:div`.


The simulation can now be run but, of course, we have yet to add code to the various functions. Here, we'll just add code snippets but if you prefer, you can create a java project and add the code there instead (*ref tut2*).

===== Java code

. Add a `snippet` to each of the three`functions` and two `initFunctions` in the specifications. Add the following code to the `JavaCode` property of each snippet:

`function:InitComm`:

[source,Java]
-----------------
double initFreq = 1.0 / x.size();
focalDrv.x.fillWith(initFreq);
for (int i = 0; i < r.size(0); i++) {
	focalCnt.r.setByInt(random.nextDouble(), i);
	focalCnt.K.setByInt(5.0 + initFreq + random.nextDouble(), i);
	for (int j = 0; j < alpha.size(1); j++) {
		if (i == j)
			focalCnt.alpha.setByInt(1.0, i, j);
		else
			focalCnt.alpha.setByInt(max(0.0001, random.nextDouble()), i, j);
	}
}
-----------------


`function:InitDist`:

[source, Java]
-----------------
focalCnt.freq = 5 + random.nextInt(50);
focalCnt.inten = random.nextDouble()*100;
-----------------

`function:CommGrowth`:
[source, Java]
-----------------
// growth
double[] dxdt = new double[x.size(0)];
for (int i = 0; i < x.size(0); i++) {
	double sum = 0;
	for (int j = 0; j < alpha.size(1); j++)
		sum += alpha.getByInt(i, j) * x.getByInt(j);
	dxdt[i] = r.getByInt(i) * x.getByInt(i) * (1 - sum / K.getByInt(i));
}
for (int i = 0; i < dxdt.length; i++)
	focalDrv.x.setByInt(Math.max(x.getByInt(i) + dxdt[i] * dt, 0.0), i);

// compute diversity
double xtot = 0.0;
for (int i = 0; i < focalDrv.x.size(0); i++)
	xtot += focalDrv.x.getByInt(i);
focalDec.div = 0.0;
for (int i = 0; i < focalDrv.x.size(0); i++)
	if (focalDrv.x.getByInt(i) > 0.0)
		focalDec.div -= (focalDrv.x.getByInt(i) / xtot) * log(focalDrv.x.getByInt(i) / xtot);

// increment 'time since disturbance'
focalDrv.tsd = tsd +1;
-----------------

`function:DistOccurrence`:
[source, Java]
--------------------
if (random.nextDouble() < 1.0 / freq)
	return true;
else
	return false;
--------------------

`function:DistEffectsComm`:
[source, Java]
---------------------
// reset time since disturbance
otherDrv.tsd = 0;
for (int i = 0; i < other_x.size(); i++)
	if (other_x.getByInt(i) > other_K.getByInt(i) * inten / 100000.0)
		otherDrv.x.setByInt(otherDrv.x.getByInt(i) * other_K.getByInt(i) * inten / 100000.0, i);
---------------------

==== User interface

There are two things that would be useful to show: allow for a large number of species and therefore show 'x' and 'div' in separate charts; and display an xy plot of 'tsd' by 'div'.

==== Next

The next tutorial introduces the event timer to drive disturbance.
