=== Tutorial 3: Using tables 

==== Introduction 

This tutorial introduces the use of tables in _ModelMaker_ by implementing a multi-species competitive Lotka-Volterra equation (CLV).

The equation has three _constants_ and one _driver_; all of which are tables:

- _K_: carrying capacity
- _r_: growth rate
- _alpha_: interspecific competition coefficient; and a driver,
- _x_: population size. 

==== Specifications

Apart from the use of tables and a more elaborate model equation, these specifications are very similar to those of Tutorial 1. _ModelMaker_ provides a library of model templates for common model patterns such this. One of these, the `SimpleClock` template, has already defined a system which is _permanent_, _atomic_, belongs to the _arena_, has a 'clock' timer driving a single process and function, a simple experimental design and a basic user interface.

. Start _ModelMaker_ and create a new: `Projects -> New -> Templates -> 2 SimpleClock` and name the project 'Tut3'.

===== Data definition

Data is defined through the recursive use of tables and records: records can contain tables and tables can contain records without limit. Records can also contain fields of any primitive Java type. Tables can also contain Java primitive types as well as user-defined records. Tables can have any number of dimensions.

There is usually more than one way of defining the data for any model. For the CLV, we will use a 2-dimensional table for _alpha_, a 1-dimensional table for  _r_ and _K_ and another 1-dimensional table for the population _x_.

[start = 2]

. Collapse all sub-trees from the root node and then expand `dataDefinition:dDef`.

. Delete `record:dec`. This record was provided by the template is not needed here.

. Create a `table` as a child of `record:cnt`, name it 'alpha', choose `dataElementType` and then set its type to `Double` (the default).

. Create a second `table` as child of `record:cnt`, name it 'r' and choose `dataElementType` and then set its type to `Double`.

. Create a second `table` as child of `record:cnt`, name it 'K' and choose `dataElementType` and then set its type to `Double`.

. Create a  `table` as child of `record:drv`, name it 'x', choose `dataElementType` and set its type to `Double`.

To complete the definition, we must set the table dimensions and indexing order for the 2-dim table 'alpha'. 

Only one dimensioner is needed: the number of species. This is done by creating a single `dimensioner` node to be associated with all these tables.

[start = 8]

. Create a `dimensioner` as a child of `dataDefinition:dtDef` and name it 'nspp'.

A new task appears in the task list saying the 'size' property must be greater than zero.

[start = 9]

. Click on `dimensioner:nspp` and go to the `Selected properties` tab. Set a value of `npp#size` to 4 (four species).

Finally, locate the `description` property for each of these tables and add the text from the introduction above. This text, together with other property meta-data such as `range` and `units`, appears as part of the Java documentation when generating Java code from _ModelMaker_. These descriptions are also used when generating the ODD document.

There are now four tasks in the task list indicating we have yet to associate the dimensioner the the four tables. _K_, _r_ and _x_ have one dimension and _alpha_ has two.

[start = 10]
. Right-click on each table node in turn and select `New edge -> dimensioner:nspp`. Repeat this for `table:alpha` to get the second dimension.

Now set the rank order for the indexing of `table:alpha`.

[start = 11]

. Click on `table:alpha` and examine its properties in the `Selected properties` editor.

. Set the value of one of its rank properties to 1 - it doesn't matter which.

===== Dynamics

Although the task list is now empty (i.e. the specifications are now deployable), we have yet to write the model equation and provide some output. We can now rename the function provided by the template to something meaningful in the present context and add a data tracker to follow _x_.


. Expand the `system.sys1` sub-tree from the root node and re-apply the layout.

. Right-click on `Function:F`, select `Rename node` and name it 'Growth'. If the prompt is unresponsive, remember to begin the name with an upper case letter.

. Create a `dataTracker` as a child of `process:p` and select `DataTrackerD0` as the type (the default).

. Create an edge from the data tracker to _x_: `trackTable -> table:x`.

There are now two tasks in the list, one about 'indexing' and the other asking which 'component' to track. As with the previous tutorials, the component to track is the `system.sys1` node.

[start = 4]

. Create the edge `trackComponent -> system:sys1` from the data tracker node.

As we are using a scalar data tracker (`DataTrackerD0`) to follow a table, we must specify which element of `table:x` to track. Indexing is a property of the edge between data tracker and the table. Edge properties appear in the property list of nodes that are at the start of the edge (thin line) - in this case `dataTracker:trk1`.

[start = 5]

. Click on `dataTracker:trk1` and in the _Selected properites_ tab, edit the `trks#index` property by clicking the editor button (*...*). 
The prompt shows the range of this table - here [0:3] being 4 elements. We can select any or all of these elements. For now choose all of them ('[0:3]'). Check the validity of the entered expression with the 'validate' button. 

This indexing will provide four data outputs. Indexing statements can select any number of contiguous or discontiguous table elements. The syntax is the same as that found in the 'R` statisical software.

===== User interface

We can now add some additional widgets to the user interface as the template provided only a controller. 

. Hide all nodes and expand the `userInterface:gui` node.

. Add a `tab` as a child of `userInterface:gui`.

. Add a `widget` as a child of `tab:tab1`, name it 'srsx' and select `SimpleTimeSeriesWidget` as the widget class.

. Add a second `widget` as a child of `tab:tab1`, name it 'tblx' and select `SimpleDM0Widget`.

Both these widgets are compatible with this data tracker class: the `SimpleTimeSeriesWidget` produces a chart while the `SimpleDM0Widget` displays the data as a continuously updated table. The task list requires these widgets to be connected to a data tracker. 

[start = 5]

. Right-click on each of these widgets in turn and select `New edge -> trackSeries -> dataTracker:trks`.

Save the specifications (`Ctrl+s`) and they're now ready to run. The next step is to create a Java project to write the 'Growth' and 'Init1' functions, the latter having been provided by the `SimpleClock` template we started this tutorial with. 

===== Link to a Java project

. Follow the steps in Tutorial 2 to create a Java project with _Eclipse_ and name it 'tut3'.

. Link it to this _ModelMaker_ project.

. Open `Tut3.java` in the _Eclipse_ editor and enter the following source code between the relevant insertion markers:

`init`:

[source,Java]
-----------------
for (int i = 0; i < r.size(0); i++) {
    focalCnt.r.setByInt(random.nextDouble() * 2.0, i);
	focalCnt.K.setByInt(0.2 + random.nextDouble(), i);
	for (int j = 0; j < alpha.size(1); j++) {
	    if (i == j)
		    focalCnt.alpha.setByInt(1.0, i, j);
		else
		    focalCnt.alpha.setByInt(random.nextDouble(), i, j);
	}
}
for (int i = 0;i<x.size(0); i++)
    focalDrv.x.setByInt(0.2, i);
-----------------

The above method simply initialises the equation constants: growth rate (_r_), carrying capacity (_K_) and the interspecific competition coefficient (_alpha_)to random values and the population size (_x_) to 0.2. 

There is a default random number generator (RNG) available to all functions. In later tutorials we will show how the specifications can factor any number of RNGs into groups. For example, one RNG can be assigned to functions of a particuar type such as those effecting reproduction or mortality.

_ModelMaker_ has two types of RNG classes in addition to the standard Java RNG. These two are faster and produce streams of higher quality than the standard Java RNG. There are also various ways of seeding RNGs to ensure their uniqueness and to help with debugging.  


'growth`:

[source,Java]
-----------------
double integrationStep = 0.01;
double[] dxdt = new double[x.size(0)];
for (int i = 0; i < x.size(0); i++) {
    double sum = 0;
	for (int j = 0; j < alpha.size(1); j++)
	    sum += alpha.getByInt(i, j) * x.getByInt(j);
	dxdt[i] = r.getByInt(i) * x.getByInt(i) * (1 - sum / K.getByInt(i));
	}
for (int i = 0; i < dxdt.length; i++)
    focalDrv.x.setByInt(x.getByInt(i) + dxdt[i] * dt * integrationStep, i);
-----------------

The model is now ready to run. However, you may want to change the time duration of the simulation from the template default of 100 to 1,000 steps.


==== Next

The next two tutorials (4 & 5) begin to elaborate the Lotka-Volterra model by developing the `structure` sub-tree through the addition of a disturbance component. 


