=== Tutorial 3: Using tables 

==== Introduction 

This tutorial implements a competitive Lotka-Volterra equation (CLV) with N-Species to demonstrate the use of tables in _ModelMaker_.

The equation has three _constants_ and one _driver_:

- _K_: carrying capacity
- _r_: growth rate
- _alpha_: interspecific competition coefficient
- _x_: population size. 

==== Specifications

For convenience, we start building the specifications from a library of model templates. Apart from the use of tables and a more elaborate model equation, these specifications are very similar to those of Tutorial 1 and 2. The template has already defined a _permanent individual_ residing in an _arena_, a 'clock' timer driving a single process and function, a simple experimental design and a basic user interface.

. Start _ModelMaker_ and create a new: `Projects -> New -> Templates -> 2 SimpleClock` and name the project 'Tut3'.

===== Data definition

[start = 2]

. Collapse all sub-trees from the root node and then expand `dataDefinition:dDef`.


. Create a `table` as a child of `record:cst`, name it 'K', choose `dataElementType` and then choose `Double` as the table type.

The type of a table can be any of the standard Java elemental types such as integers, booleans etc, or they can be tables of records whose contents are defined later. Used recursively, tables and records can encompass all the data requirements in the model's specifications. 

[start = 5]

. Create two more tables as children of `record:cst`, named 'r' and 'alpha' and set both as `dataElementType` of type `Double`.

. Create a `table` as a child of `record:drv`, name it 'x' and again set it as `dataElementType` of type `Double`.

To complete the definition, we must set the table dimensions, their indexing order and add a description to each table. Only one dimensioner is needed: the number of species. This is done by creating a single `dimensioner` node to be associated with all the newly created tables.

[start = 7]

. Create a `dimensioner` as a child of `dataDefinition:dtDef` and name it 'nspp'.

A new tasks appears in the task list saying the 'size' property must be greater than zero.

[start = 8]

. Click on `dimensioner:nspp` and go to the `Selected properties` tab. Set a value of `npp#size` to 4 (four species).

Finally, locate the `description` property for each of these tables and add the text from the introduction above. This text, together with other property meta-data such as `range` and `units`, appears as part of the Java documentation when generating Java code from _ModelMaker_.

There are now four tasks in the task list indicating we have yet to associate the dimensioner the the four tables. _K_, _r_ and _x_ have one dimension and _alpha_ has two.

[start = 9]
. Right-click on each table node in turn and select `New edge -> dimensioner:nspp`. Repeat this for `table:alpha` to get the second dimension.

Now set the rank order for the indexing of _alpha_.

[start = 10]

. Click on `table:alpha` and examine its properties in the `Selected properties` editor.

. Set the value of `SzBy5#rank` to 1 (assuming you've used the default names for the newly created edges to the dimensioner node).

Although the task list is now empty (i.e. the specifications are now deployable), we have yet to write the model equation and provide some output. First, rename the function provided by the template to something meaningful in the present context, and add a data tracker to follow _x_.

===== Dynamics

. Right-click on `Function:F`, select `Rename node` and name it 'Growth'.

. Create a data tracker as a child of `process:p` and select `DataTrackerD0` as the type.

. Create an edge from the data tracker to _x_: `trackTable -> table:x`.

There are now two tasks in the list, one about 'indexing' and the other asking which 'component' to track. As with the previous tutorials, the component to track is the `system.sys1` node.

[start = 4]

. Create the edge `trackComponent -> system:sys1` from the data tracker node.

As we are using a scalar data tracker (`DataTrackerD0`) to follow a table, we must specify which element of `table:x` to track. Indexing is a property of the edge between data tracker and the table. Edge properties appear in the property list of nodes that are at the start of the end (thin line) - in this case `dataTracker:trk1`.

[start = 5]

. Click on `dataTracker:trk1` and in the _Selected properites_ tab, edit the `trks#index` property by clicking the editor button (*...*). 
The prompt shows the range of this table - here [0:3] being 4 elements. We can select any or all of these elements. For now choose all of them ('[0:3]'). Check the validity of the entered expression with the 'validate' feature. 

This indexing will provide four data outputs. Indexing statements can select any number of contiguous or discontiguous table elements. The syntax is the same as that found in the 'R` statisical software.

===== User interface

We can now add some additional widgets to the user interface. The template provided only a controller. 

. Hide all nodes and expand the `userInterface:gui` node.

. Add a `tab` as a child of `userInterface:gui`.

. Add a `widget` as a child of `tab:tab1`, name it 'srsx and select `SimpleTimeSeriesWidget` as the widget class.

. Add a second `widget` as a child of `tab:tab1`, name it 'tblx' and select `SimpleDM0Widget`.

Both these widgets are compatible with this data tracker class: the `SimpleTimeSeriesWidget` produces a chart while the `SimpleDM0Widget` displays the data as a continuously updated table. The task list requires these widgets to be connected to a data tracker. 

The specifications are ready to run and we can now create a Java project to write the 'Growth' and 'init' functions, the latter having been provided by the `SimpleClock` template we started this tutorial with. 

===== Link to a Java project

. Follow the steps in Tutorial 2 to create a Java project with _Eclipse_ and name it 'tut3'.

. Link it to this _ModelMaker_ project.

. Open `Tut3.java` in the _Eclipse_ editor and enter the following source code between the relevant insertion markers:

[source,Java]
-----------------
#// init1 ---- Code insert Begin-->
for (int i = 0; i < r.size(0); i++) {
    focalLtc.r.setByInt(random.nextDouble() * 2.0, i);
	focalLtc.K.setByInt(0.2 + random.nextDouble(), i);
	for (int j = 0; j < alpha.size(1); j++) {
	    if (i == j)
		    focalLtc.alpha.setByInt(1.0, i, j);
		else
		    focalLtc.alpha.setByInt(random.nextDouble(), i, j);
	}
}
for (int i = 0;i<x.size(0); i++)
    focalDrv.x.setByInt(0.2, i);
#// init1 ---- Code insert End----<
-----------------

The above method simply initialises the equation constants: growth rate (_r_), carrying capacity (_K_) and the interspecific competition coefficient (_alpha_) with random values. 

There is a default random number generator (RNG) available to all functions. In later tutorials we will show how the specifications can factor any number of RNG into groups so, for example, one RNG can be assigned to functions of a particuar type such as those effecting reproduction or mortality.

_ModelMaker_ has two types of RNG classes in addition to the standard Java RNG. These two are faster and produce streams of higher quality. There are also various ways of seeding RNGs to ensure their uniqueness and to help with debugging.  

[source,Java]
-----------------
#// growth ---- Code insert Begin-->
double integrationStep = 0.01;
double[] dxdt = new double[x.size(0)];
for (int i = 0; i < x.size(0); i++) {
    double sum = 0;
	for (int j = 0; j < alpha.size(1); j++)
	    sum += alpha.getByInt(i, j) * x.getByInt(j);
	dxdt[i] = r.getByInt(i) * x.getByInt(i) * (1 - sum / K.getByInt(i));
	}
for (int i = 0; i < dxdt.length; i++)
    focalDrv.x.setByInt(x.getByInt(i) + dxdt[i] * dt * integrationStep, i);
#// growth ---- Code insert End----<
-----------------

The model is now ready to run. However, you may want to change the time duration of the simulation from the template default of 100 to 1,000 steps.


==== Next

The next two tutorials (4 & 5) begin to elaborate the Lotka-Volterra model by developing the `structure` sub-tree for the first time. 

A disturbance component is added to the specifications to test the Intermediate Disturbance Hypothesis. 

So far, we have used a 'Clock' timer to drive the simulations. Tutorial 6 introduces event timer class.

