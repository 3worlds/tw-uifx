=== Tutorial 1: Construct and run a simulation for the first time

==== Introduction 

In this tutorial we demonstate the procedure for creating a simulation using _ModelMaker_. To keep the focus on the procedure, we implement a very simple logistic function as a simulation leaving more complex models to later tutorials.

In _3Worlds_, a simulation model is defined by constructing a graph of nodes and edges and setting their properties. Nodes in the graph represent elements of interest in the model and the edges represent the relationships between them. The entire graph constitutes the model specifications. The simulation can be run as as soon as the specifications are complete.

As you construct the graph, _ModelMaker_ is constantly checking and providing feedback on how these specifications comply with an _archetype_. _ModelMaker_ guides you through this process by managing the available options at each stage in the graph construction and providing an updated list of tasks requiring attention. 

While this process greatly accelerates model development, a more important aim is to provide a firm basis for model comparison. As all models developed with _ModelMaker_ must comply with the _archetype_, structural differences are apparent by comparing specifications. That is, while you can construct any model, the design, being constrained by the _archetype_, will not be arbitrary. Of course, this is not the only difference between models. The code for each function defined by the specifications will be particular but at least these differences are encapsulated at specific places in the model implementation.

The graph is both a tree and a directed graph. Aside from the root, each node has a parent and may have additional edges from one node to another to define particular relationships. We refer to these edges as _cross-links_ to distinguish them from edges that represent _parent-child_ relationships. Once the task list is empty, the simulation is ready to run.

If you haven't read any other _3Worlds_ documentation, reading "About ModelMaker" from the main menu (`Help -> About`) will provide some preliminary context.

==== Creating a new 3Worlds project

. Start `ModelMaker`.
. Create a new project (`Main menu: Projects -> New -> Templates -> Blank`)
. When prompted enter `Tut1` (first letter uppercase). A single node called  `3Worlds:Tut1` now appears centred in the _Graph display_.

This node will be the _root_ of a graph that forms the model specifications. All nodes are identified by a _label:name_ pair. The _label_ is the type of node, representing its role, while the _name_ is a unique identifier. A few node types, of which the root node is one, must have names beginning with an uppercase letter. These nodes are used to generate Java classes when the simulation compiles.

At this stage you can try out a few basic edit operations:

- Move a node around the graph display by dragging it with the left mouse button;

- Zoom in and out in the graph display using the mouse wheel while holding down the `ctrl` key (or equivalent on your operating system). The focus of the zoom is set by the mouse position;

- Pan the drawing surface by dragging with the left-mouse button anywhere outside a node;

- Change the node and text size with the controls at the bottom of the display; and,

- See a range of edit options for this particular node by right-clicking on it to display a local popup menu.

A list of tasks remaining to be completed appears at the bottom-left of the main window. This list grows and shrinks as the developing graph is checked against the archetype.  A check takes place in the background every time the graph structure or its properties change. 

At the top-left of the main window are the two property editors - _Properties_ and _Selected Properties_.  These show properties for the entire graph or for a single selected node (selected by clicking on the node with the left button) respectively. It's here that values are entered for the properties of nodes and edges created in the following steps. At this stage, there are five properties under the section `Tut1`.  These are properties of the root node (`3worlds:Tut1`) intended provide a minimal amount of documentation for this project. By default, the property '`build-by`' is filled out with your computer login name and the creation date of the project.

At the bottom of the graph display are a number of controls that will be explained below. Float the mouse over these controls to see a hint as to their purpose.

===== Directory structure

All projects are located within the 3Worlds root directory called `.3w`. The dot indicates a hidden directory. To see these files you may need to do what ever is required by your operating system to show hidden files. 

Within `.3w` there is now a sub-directory called something like `project_Tut1_2020-06-07-01-47-44-708`. Every project directory begins with the key word `project` followed by the name of the project you entered (`Tut1` in this case) and the the creation date and time. The purpose of naming project directories in this way is to make it almost impossible to overwrite a project inadvertently. 

Inside this directory are a number of text files:

- `Tut1.utg` is the model configuration graph we are constructing;
- `layout.utg` contains information used to display the graph;
- `MM.xml` contains the session's preference settings.
- `__StateA1` and sequences of similarly named files are temporary files to support the program's undo/redo editing operations. These files are created during a session and deleted when the session ends.  

All these files are text files and you can open them with a simple text editor. However, _editing these files will likely to lead to problems for your project_. On the other hand, you can safely delete project directories at any time if you wish. If you accidentally delete the project of a currently open session, it will be recreated automatically by _ModelMaker_ apart from the _undo-redo_ data. However, if you delete the entire .3w directory you will loose the `tw-dep.jar` file. You should keep a backup of this jar as it contains all Java dependencies for _3Worlds_.


==== Creating the specifications

The task list currently shows four nodes are required. This list can be dealt with in any order but in general, a good approach is to build the specifications in the order: 

... data
... dynamics
... structure

===== Data

The logistic equation to implement is: _x(t+1) = rx(t)(1-x(t)_. Thus, parameter _r_ and the variable _x_ must be defined first. From here on and throughout these tutorials, parameters will be called _constants_ and variables _drivers_.

To follow along with this tutorial, accept the prompt default names of nodes unless otherwise indicated.

. Right-click on the root node (`3worlds:Tut1` ) and select `New node -> dataDefinition` from the popup menu. You're then prompted for a name. The default name is `dDef`. Accept this and click `ok`. The mouse pointer immediately becomes a cross-hair: _ModelMaker_ is asking where to place this node. Move to some place within the graph display and left-click the mouse. 

The `dataDefinition:dDef` node appears (pale red) connected by a green line to the root node (black). Green lines indicate a parent-child relationship between nodes. These lines are thicker at the child end and can be read as "`3worlds:Tut1` has a `dataDefinition:dDef`.

All nodes in the configuration graph are children of some parent (apart from the root node). You can only create nodes by right-clicking on a parent and making a selection from the popup menu. The items in this menu vary according to the possibilities allowed by the _archetype_. This is one way _ModelMaker_ ensures the developing configuration conforms with the _archetype_, greatly simplifying an otherwise very complex workflow.

[start = 2]
. Create a `record` node as a child of `dataDefinition:dDef` and name it 'cst'.

. Create a `field` node as child of `record:cst`, name it 'r' and when prompted, set its type as `Double`.

All `fields` (and later `tables`) must be children of a `record`. 

[start = 4]

. Create another `record` as child of `dataDefinition:dDef` and name it 'drv'.

. Create a `field` node as child of `record:drv`, name it 'x' and again set the type to `Double`.

Note that the names 'drv' and 'cst' don't imply any meaning to the specifications - they're just names. Their roles as drivers and constants will be defined later. 

This is all the data required for this tutorial.  The task asking to add a `dataDefinition` node has now gone and three tasks remain.

===== *Dynamics*

Dynamics specifies how the modelled system evolves over time. In the present case it's simple enough to call the equation a set number of times and provide the result from the previous time step to the equation at the current time step. The `dynamics` sub-tree is a child of the `system` node - the root of the modelled system that defines both its dynamics and its structure. 

To begin defining the system dynamics, create a `system` node and then a `dynamics` node as its child.

. Right-click on the root node (`3worlds:Tut1` ) and select `New node -> system` from the popup menu. 

The addition of the `system` node has removed one task (to add a `system`) and added four more to the task list. One of these tasks (#4) is to add a `dynamics` node.

[start = 2]

. Add a `dynamics` node as a child of `system:sys`.

A lime green node labelled `dynamics:sim1` appears. This is the root of the dynamics sub-tree and when the specifications are run, this node is the specification of a type of simulator. There can be many simulators of this specification running in parallel depending on the experimental design.

In the `dynamics` sub-tree, we create, in order, nodes called `timeLine`,`timer`, `process`, `function` and `dataTracker`.

[start =3]

. From the `dynamics` node create a `timeline` node. The timeline defines the time scale type for the simulation. 

In the properties editor, the drop-down list for the `tmln1#scale` property shows ten different types are available: all of them exact sub-divisions of time except for the Gregorian scale type which implements the standard Gregorian calendar. The default is `ARBITRARY` which is fine for this tutorial. There is now a new task to add a `timer` node to the `timeline`.

[start = 4]

. From the `timeline` node, create a `timer` node. Here an extra prompt appears asking for the class of the timer: {`ClockTimer`, `EventTimer`, `ScenarioTimer`}. Select `ClockTimer`. This class increments time by a constant step during simulation, unless the timeline uses a Gregorian scale in which case irregularities such as leap years are managed. 


There is now a new type of task indicating a property value for the new timer is incorrect : `[Property] ['[Property:dt=0]' does not satisfy '[Property 'dt=0' must be within [1.0; 9.223372036854776E18].]']`. This just means the value of `dt` must be >= 1.

[start=5]

. In the property editor, change `tmr1#dt` to 1, whereupon a new task appears saying the same thing for `tmr1#nTimeUnits` so set that to 1 as well. 

`dt` is the time unit size and `nTimeUnits` is the number of time units per simulation step. There are 22 time unit types available ranging from microseconds to millennia. The current default value of `UNSPECIFIED` is fine for this tutorial - time here is just a sequence of steps. 

Note that a model can have any number of `timers` using any of the available time steps and time units as long as the time units selected are compatible with the parent `timeline`. The task messages will indicate if this is not the case. Because the specifications allow for more than one system, it follows there can be many dynamics sub-trees, each with their own time system.

A new task has been posted requiring a `process` node.

[start = 6]

. Create a process node as child of `timer:tmr1`. 

A process is a set of computations acting on model components driven at the rate of the parent `timer`. A '*component*` is anything you want to include in your model such as plants, animals, nutrient pools, lakes, the atmosphere or the rhizosphere. In short, any phyisical or biology entity that has dynamic behaviour.

Processes can be composed of any number of functions of ten different types. We need just one function to implement the logistic equation - a `ChangeState` function that takes the current state of a component and calculates the next state.


*UP TO HERE ON REWRITE*

Two new tasks have appeared requiring that the process we just added have a `function` or `dataTracker` child and that it should have an edge to a `category` or `relationType`. The latter message defines the entity or _category_ the process is applied to - in our case, `category:*arena*` . 

[start = 6]

. Right-click on `process:p1` and select 'New edge -> appliesTo -> category:*arena*'.


. Create a function node as a child of `process:p1`. Name it "Chaos" as this logistic equation can have interesting chaotic behaviour. After naming the function, a prompt appears for the function type. Select the first option `ChangeState`. 

The function type can't be changed after the node is created. If you've made a mistake, delete the node (or "undo") and recreate it. The name of a function node can only start with an uppercase letter. Functions directly translate into Java classes which, by convention, begin with an uppercase letter.

The logistic equation is _x(t+1) = rx(t)(1-x(t)_. To view the value of _x_ we use a dataTracker connected to `process:p1`. 

[start = 8]

. Create a `dataTracker` node as a child of `process:p1`. _x_ is a scalar variable so when prompted for the dataTracker type, select `dataTrackerD0` (zero dimensions).

There is now a new task saying the dataTracker needs to be connected to something (a field, table or component). In a complex model requiring a `structure` sub-tree, many different components can be defined. These will be discussed in later tutorials. In this tutorial, the 'model' is just a single equation and the `system` node can stand in for a component. Therefore, we can connect `dataTracker:trk1` to `system:sys`.
Two of these tasks are asking for edges to be added from the `system:sys1` node. However, it's not apparent where these nodes are at this stage. 

*Connecting to the predefined sub-tree*: Although we started this project from a supposedly "Blank" template, in fact it's not blank:  a sub-tree has already been added and hidden from view when the project was created. To view this sub-tree:

[start=2]

. Right-click on root node and select `expand -> predefined:*categories*`.

This sub-tree (all grey nodes with two red cross-link edges) cannot be edited apart from adding edges to nodes outside this sub-tree. With these edges we will define the newly added system as a "permanent individual residing in an arena". It's _permanent_ because the entity does not die, it's an _individual_ because it's not an aggregate of smaller components and it resides in an _arena_ because, well, everything's got to be somewhere. This seems cumbersome for just a simple equation but it hints at what is a very powerful approach to structuring complex hierarchical dynamic systems of interacting physical and biological components. The system structure will be elaborated upon over the course of these tutorials.

The _predefined_ sub-trees has many nodes which can be ignored for now and can be hidden to simplify the _graph display_. To do this:

[start = 3]

. Right-click on the `predefined:*categories*` node and select `Collapse -> All`

. Right-click again on `predefined:*categories*` and select `Exapnd -> categorySet:*composition*`.

. Repeat this for `categorySet:*lifespane*` and `categorySet:*systemElements*`.

. Right-click on `categorySet:*systemElements*` and select `Collapse -> All`.

. Right-click again on `categorySet:*systemElements*` and select `Exapnd -> category:*arena*`.

. Finally, re-apply the layout by clicking the "*L*" button.


The first task in the list is to create an edge from the system node to a category node named "\*arena*" (`1. [Edge] Add edge [belongsTo:] from 'system:sys1' to [category:*arena*]`). This defines where this equation "resides".

[start=9]

. Right-click on `system:sys1` and select `New edge -> belongsTo -> category:*arena*` and accept the default name for this edge.  

A red _cross-link_ line then appears between these two nodes with the line thicker at the _end node_. All cross-link lines are red and all parent-child lines are green. You can show or hide these types of lines using the '*X*' or '*<*' toggle buttons at the bottom of the graph display.

The task list has now updated. The task just completed has gone and an new message indicating that the configuration is unsaved has appeared.

[start=10]
. Press `Ctrl+s` to save.

. Repeat the above steps for the next task `1. [Edge] Add edge [belongsTo:] from 'system:sys1' to [category:*permanent*]`. Biological components are born, reproduce and die. The logisitic equation does none of these so it's defined as _permanent_ rather than _ephemeral_.

The next task is essentially the same thing but expressed slightly differently. It asks that we connect an edge from the system node to either a node named \*individual* or \*population*. 

[start=12]
. Repeat the above steps and select `New edge->belongsTo->category:*individual*`. Again, the logistic equation is not composed of sub-components - it's just an equation - so it's defined as an _individual_ rather than a _population_.


We've finished with the predefined sub-tree for the moment. However, we'll return later to make other edges to the `category:*arena*` but can collapse the other two sub-trees.

[start=13]
. Right-click on `predefined:*categories*` and select `Collapse -> categorySet:*composition*` and `categorySet:*lifespan*`.

Notice that the two red _cross link_ edges have disappeared. Once you're familiar with this sub-tree, you can, in fact, create edges *to* it without expanding it (or any other sub-tree) as we've just done. To provide some visual clue that the addition has occured, the newly created edge is shown initially and then slowly fades way.


*Dynamics sub-tree*: We now continue with the task associated with the system node. This is to create the `dynamics` sub-tree (task 2). In this simple model, we don't need to create a `structure` sub-tree. The need for that has been dealt with in this simple example by the connections we just made to the `predefined` sub-tree.
 
In the `dynamics` sub-tree, we create, in order, nodes called `timeLine`,`timer`, `process`, `function` and `dataTracker`. All nodes this sub-tree are lime green. To follow along easily, accept the default names unless otherwise indicated.

. Create a `dynamics` node as a child of `system:sys1`. This node represents the simulator.





[start = 9]

. Right-click on `dataTracker:trk1` and select `New edge -> trackComponent -> system:sys1'.

The task list is now complaining that we also need an edge to a field or table. We can't do anything about this until we have defined some data.



[start = 6]

. Right-click on `dataTracker:trk1` and select `New edge -> trackField->field:x`.

A new task appears saying that the "x" being tracked doesn't belong to any category associated with 'process:p1'. This is where we define "x" as a "driver": data that changes over the course of the simulation. Recall, the category the process applies to is `category:*arena*` (i.e. the _cross link_ `appliesTo:aplyTo1` in the graph display). To define "x" as a driver:

[start = 7]

. Right-click on `category:*arena*` and select 'New edge -> drivers->record:drv'.

Note that this edge is to `record:drv` rather than `field:x`. The `dataDefinition` sub-tree can become quite elaborate. It incorporates records and tables of any number of dimensions defined recursively. That is, records can contain tables that contain records and so on with out limit.  In the present case, any additial data defined in a sub-tree from `record:drv` will be a defined as a driver in the model.

There are now two tasks listed but before dealing with these, we have yet to finally enter code for the logistic equation.

*Inline code snippets*: _ModelMaker_ can link to an Integrated Development Environment (IDE) such as _Eclipse_, to write code for these functions. In this tutorial however, the situation is simple enough that we can just associate a code snippet with the function without the need to link to an IDE. The snippet will be inserted in the function when the simulation is compiled.

[start = 8]

. Create a `snippet` node as a child of `function:Chaos`. 

. In the property editor, locate the `snpt1#javaCode` property, click the edit button ('*...*') and enter the following text:
`focalDrv.x = r*x*(1-x);`





*Experiment*: We now create an experiment, which in this case is the simplest possible: a single run of the model.

. Create an `experiment` node as a child of the root.

. From the `experiment:expt` node create a `design` node. When prompted, select the `type` property. Experimental designs can take many forms including predefined types such as `crossFactorial` or designs read from a file. For now we just use a predefined `type` - the default value is `singleRun`.


*User interface*: We now define the simulator's user interface. We will need at least a widget to control the simulator (start, step, stop and pause) and one for output (a time series chart of _x_) but will add this later after trying out the simulator. 

When the simulation is run, its user interface has optionally, a toolbar at the top, a status bar at the bottom and any number of tabs containing any number of widgets. The controller must be placed either in the toolbar or status bar. Here we place it in the toolbar.

. Create a `userInterface` node from the root node.

. Create a `top` node from the `userInterface:gui` node.

. Create a `widget` node from the `top:top` node, name it 'ctrl' and select `SimpleControlWidget1` from the drop-down list.

==== Running the model for the first time

The model specifications now comply with the archetype and the code has compiled. Save your work (`Ctrl+s`) and the task list will be empty. The *Deploy* button is now enabled and the traffic light has changed from red to green (bottom left corner of _ModelMaker_).

. Click the `Deploy` button. _ModelMaker_ now launches _ModelRunner_ to start the run-time application. 

At the top of _ModelRunner_ are some control buttons to start, step and stop the simulation. This is the `SimpleControlWidget1` we added above. They work analogously to DVD player controls. The run button becomes a pause button while running and the stop button resets the simulator to its starting state. 

However, there is no output as we've yet to add an output widget. This is an optional requirement so the task list was silent on this point.

To add a time series for "x":

[start = 2]

. Quit _ModelRunner_ and return to _ModelMaker_.

. Create a `tab` node from the  `userInterface:gui` node. 

. Create a `widget` node from `tab:tab1`, name it `srsx` and select `SimpleTimeSeriesWidget` from the drop-down list. 

A new task has been added to the list requiring an edge from this widget to a dataTracker.

[start = 5]

. Create a `trackSeries` edge from `widget:srsx` to `dataTracker:trk1`. This connects the 'srsx' widget to the _x_ variable through the intervening data tracker. Data trackers work in an analogous way to real data trackers in the field. They track some environmental variable and can optionally produce some statistical treatment of the raw data before sending to a widget for display.
 
*Stopping conditions*: If you examine the graph and all its properties, you may notice that there is no indication as to how long the simulation should run. This means that when we run it we should expect it to continue indefinitely. You may or may not want this. If your model contains an unconstrained exponential graph function, it may eventually crash unless your code takes measures to handle this. You can add a variety of simple or complicated stopping conditions to the `dynamics` node. These will be discussed in later tutorials.

When we first ran this model it had no output. Now that we have a time series chart, displaying data of unlimited length will make the _ModelRunner_ fairly unresponsive. If you press the run button and then the stop or pause button it may take a while for the model to actually stop running. So for now, it's best to test the simulation with the `Step` button.
[start =6]

. Deploy _ModelRunner_ (saving first if prompted)

. Click the `step` button a few times. A time series of zeros is shown. 

. Click the `run` button twice in rapid succession. The time (x axis) now reads approximately 30,000 or so depending on the speed of your computer.

The display is still uninteresting because we have not set an initial value for _x_ or parameterised _r_. This can be done in a number of ways but for this tutorial we can just add nodes to the graph that set these two values.

[start=9]

. Quit _ModelRunner_ and return to _ModelMaker_.

. Right-click the the `system:sys1` node, add a `variableValues` node.

. Select this new node and in the _Selected properties_ editor, set the `initVars1#x` property value to 0.001.

. From the `system:sys1` node, add a `constantValues` node. 

A task has appeared now saying no properties have been defined. While we previously defined what constitues 'driver' data for the `category:*arena*`, we haven't defined what is a constant. To fix this we must delete the node, make the definition and then recreate the node:

[start = 13]

. Right-click on `constantValues:initCnst1` and select `Delete node`.

. Right-click on `category:*arena*` and select `New edge -> lifetimeConstants-> record:cst`. (*WHY NOT Parameters?*)

. Right-click on `system.sys` again, and recreate the `constantValues` node.

. Select this new node and in the _Selected properties_ editor, set the `iniCsts1#r` property value to 3.7.


To complete this tutorial, add a simple stopping condition:

[start=16]

. Quit _ModelRunner_ to return to _ModelMaker_.

. Select `dynamics:sim1` and create a `stoppingCondition` node. When prompted, select `SimpleStoppingCondition` from the drop-down list.

. Select this new node and in the properties editor, set the value of `stCd1#endTime` to 100.

. Save, re-deploy and run the simulation. You'll now see a time series of the chaos function of 100 time steps.

As an alternative to adding these nodes to initialise the simulation you can add an `initFunction` and a code snippet. To do this:

. Delete the `constantValues:initCnst1` and `variableValues:initVars1` nodes.

. Right-click `system.sys` and create an `initFunction` node.

. Right-click on `initFunction:init1` and create a `snippet` node.

. In the property editor, locate the `snpt2#javaCode` property, click the edit button ('*...*') and enter the following two lines:

- `focalDrv.x =3.7;`

- `focalLtc.r = 0.001;`

If you make a typo, the task list will show the details of the compile error.

==== Graph layouts
The final aspect of _ModelMaker_ we have yet to examine is the graph layout system.

While using a graph to construct model specifications has many advantages, you can quickly become lost in a confusion of nodes and edges. The advantage in using a graph is that the huge number of options possible can be constrained by context. For example, to have a dynamic `process`, it makes sense that it's associated with a particular `timer`, that other processes working at the same rate are associated with the same `timer` and that all timers are coordinated by the one `timeline`. The user interface for problems such as this would be very error-prone if presented say, as a series of dialog boxes.

_ModelMaker_ has a number of features to help arrange the graph display. These fall into three categories: arranging,  hiding and resizing.

*Arranging*: There are five layout algorithms currently available in _ModelMaker_ of which three use the tree structure of the graph to arrange nodes and two are 'Spring' based algorithms. Tree methods are ideal for examining the parent-child structure while the last two are better suited to examining relations between nodes. Tree methods are deterministic while Spring methods are not. Thus Tree methods are better for maintaining your orientation to the graph but have the disadvantage of not arranging cross-link edges clearly. Spring methods do a better job of this but the resulting arrangement can change with each application of the layout.

Two of the Tree methods produce a radial layout. These are best suited to examining nodes that have many children such as a record with many fields.

All Tree methods allow selecting any node as the root of the tree. This is achieved from the popup menu of each node. When the "re-apply layout" button is pressed (*L*) while using a Tree method, the root of the tree becomes is the root of the graph (`3worlds:Tut1`).

When a project is first created, the default layout is an *orderedTree*. To change to other layouts, use the local popup menu for any node. This layout persists for repeated applications of the layout function until another is chosen.

You can add a random displacment to nodes to help prevent node and edge text overlapping. This setting is applied whenever the layout is re-applied.

Finally, you can of course move a node anywhere within the graph window. 

*Information hiding*: The following operations can help to hide temporally irrelevent information:

- *collapse/expand*: You can hide or show sub-trees from any node from its local popup menu. In addition, all properties of collapsed sub-trees and removed from the property editor;
- *X* Show/hide cross-link edges. 
- *<* Show/hide parent-child edges.
- *>|* Move all isolated nodes to one side (after re-applying the layout)
- *Show neighbourhood*:  With this feature, you can choose to show only nodes within a given path distance from a selected node.
- *A*: Show all nodes. That is, undo the above operation.

*Resizing*:

- *Zoom*: Zoom in and out in the graph window with the mouse pointer as the focus point (`Ctrl - mouse wheel`)
- *Pan*: If the drawing surface is larger than the window, you can drag the drawing surface of the graph window (left click outside a node)
- *Node Size*
- *Font size*


That's the end of this tutorial. Recreate this project at anytime from the main menu (`Project -> New -> Tutorials -> 1 Logistic`).

==== Next

The next tutorial (Tutorial 2) will demonstrate linking the project to an IDE and adding some Java program code.






