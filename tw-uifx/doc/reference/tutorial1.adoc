=== Tutorial 1: Construct and run a simulation for the first time

==== Introduction 

This tutorial explains the procedure for creating a simulation with _ModelMaker_. As the use of _ModelMaker_ is the primary focus of this tutorial, only a simple logistic equation is implemented as a test case. New modelling capabilities are gradually introduced over the course of these tutorials.

In _3Worlds_, the specifications for a simulation model are developed by constructing a graph of nodes and edges and setting their properties. Nodes in the graph represent elements of interest in the model and the edges represent the relationships between them. The entire graph constitutes the model specifications. The simulation can be run as as soon as the specifications are complete.

As you construct the graph, _ModelMaker_ is constantly checking and providing feedback on how these specifications comply with an _archetype_. _ModelMaker_ guides you through this process by managing the available options at each stage in the graph construction and providing an updated list of tasks requiring attention. 

While this process greatly accelerates model development, a more important aim is to provide a firm basis for model comparison. As all models developed with _ModelMaker_ must comply with the _archetype_, structural differences become apparent when comparing specifications. That is, while you can construct any model, the design, being constrained by the _archetype_, will not be arbitrary. Of course, this is not the only difference between models. The code for each function defined by the specifications will be particular but at least these differences are encapsulated at specific places in the model implementation.

The graph is both a tree and a directed graph. Aside from the root, each node has a parent and may have additional edges between nodes to define particular relationships. We refer to these edges as _cross-links_ to distinguish them from edges that represent _parent-child_ relationships. Once the task list is empty, the simulation is ready to run.

If you haven't read any other _3Worlds_ documentation, reading "About ModelMaker" from the main menu (`Help -> About`) will provide some preliminary context.

==== Creating a new 3Worlds project

. Start `ModelMaker`.
. Create a new project (`Main menu: Projects -> New -> Templates -> Blank`)
. When prompted enter `Tut1` (first letter uppercase). A single node called  `3Worlds:Tut1` now appears centred in the _Graph display_.

This node will be the _root_ of a graph that forms the model specifications. All nodes are identified by a _label:name_ pair. The _label_ is the type of node, representing its role, while the _name_ is a unique identifier. A few node types, of which the root node is one, must have names beginning with an uppercase letter. These nodes are used to generate Java classes when the simulation compiles.

At this stage you can try out a few basic edit operations:

- Move a node around the graph display by dragging it with the left mouse button;

- Zoom in and out in the graph display using the mouse wheel while holding down the `ctrl` key (or equivalent on your operating system). The focus of the zoom is set by the mouse position;

- Pan the drawing surface by dragging with the left-mouse button anywhere outside a node;

- Change the node and text size with the controls at the bottom of the display; and,

- See a range of edit options for this particular node by right-clicking on it to display a local popup menu. The graph is constructed through these popup menus.

A list of tasks remaining to be completed appears at the bottom-left of the main window. This list grows and shrinks as the developing graph is checked against the archetype.  A check takes place in the background every time the graph structure or its properties change. 

At the top-left of the main window are the two property editors - _Properties_ and _Selected Properties_.  These show properties for the entire graph or for a single selected node (selected by clicking on the node with the left button) respectively. It's here that values are entered for the properties of nodes and edges created in the following steps. 

At this stage, there are five properties under the section `Tut1`.  These are properties of the root node (`3worlds:Tut1`) intended to provide a limited amount of documentation for this project. By default, the property '`build-by`' is filled out with your computer login name and the creation date of the project.

At the bottom and right-hand side of the graph display are a number of controls that will be explained below. Float the mouse over these controls to see a hint as to their purpose.

===== Directory structure

All projects are located within the 3Worlds root directory called `.3w`. The dot indicates a hidden directory. To see these files you may need to do what ever is required by your operating system to show hidden files. 

The `.3w` directory contains a Jar file called `tw-dep.jar`. This file contains all dependent libraries for _3Worlds_. It's a good idea to keep a backup of this file.

Within `.3w` there is now a sub-directory called something like `project_Tut1_2020-06-07-01-47-44-708`. Every project directory begins with the key word `project`, followed by the name of the project you entered (`Tut1` in this case) and the creation date and time. The purpose of naming project directories in this way is to make it almost impossible to overwrite a project inadvertently. 

Inside this directory are a number of text files:

... `Tut1.utg` is the model configuration graph we're constructing;
... `layout.utg` contains information used to display the graph;
... `MM.xml` contains the session's preference settings.
... `__StateA1` and sequences of similarly named files are temporary files to support the program's undo/redo editing operations. These files are created during a session and deleted when the session ends.  

All these files are text files and you can open them with a simple text editor. However, _editing these files will likely to lead to problems for your project_. 

On the other hand, you can safely delete project directories at any time if you wish. If you accidentally delete the project of a currently open session, it will be recreated automatically by _ModelMaker_ apart from the _undo-redo_ data. However, if you delete the entire `.3w` directory you will have to restore `tw-dep.jar` from backup.


==== Creating the specifications

Having created `Tut1`, the task list shows four nodes are required. This list can be dealt with in any order but in general, a logical approach is to build the specifications as follows: 

... *data definition*: the data structures required;
... *dynamics*: how the modelled system evolves over time.
... *structure*: the organisation of components - their roles and relationships. 

For the most part, these tutorials will proceed in this order and leave defining the simulation's user interface and experimental design until last. 

These sections are organised as sub-trees of the graph, with the nodes of each sub-tree having a particular colour.

===== Data definition

The logistic equation we implement is: _x(t+1) = rx(t)(1-x(t)_. Though simple, it has interesting chaotic behaviour for values of _r_ between 3.7 and 4.0. All we need do for the data definition section is to define the parameter _r_ and the state variable _x_. 

From here on and throughout these tutorials, parameters are called _constants_ (data that does not change over the course of a simulation) and state variables _drivers_ (data that drives the simulation from one time to the next).

. Right-click on the root node (`3worlds:Tut1`) and select `New node -> dataDefinition` from the popup menu. You're then prompted for a name. The default name is `dDef`. Accept this and click `ok`. The mouse pointer immediately becomes a cross-hair: _ModelMaker_ is asking where to place this node. Move to some place within the graph display and left-click the mouse. 

You can name nodes and edges anything you like but accepting the recommended names and edges will make these tutorials easier to follow. _ModelMaker_ will prevent naming nodes or edges with duplicate names.

The `dataDefinition:dDef` node appears (pale red) connected by a green line to the root node (black). Green lines indicate a parent-child relationship between nodes. The lines are thin at the parent end and thick at the child end indicating that `3worlds:Tut1` is the parent of `dataDefinition:dDef`.

All nodes in the configuration graph are children of some parent (apart from the root node). You can only create nodes by right-clicking on a parent and making a selection from the popup menu. The items in this menu vary according to the possibilities allowed by the _archetype_. This is one way _ModelMaker_ ensures the developing configuration conforms with the _archetype_, greatly simplifying an otherwise complex workflow.

[start = 2]
. Create a `record` node as a child of `dataDefinition:dDef` and name it 'cnt'.

. Create a `field` node as child of `record:cnt`, name it 'r' and when prompted, set its type as `Double`.

All `fields` (and later `tables`) must be children of some `record`. 

[start = 4]

. Create another `record` as child of `dataDefinition:dDef` and name it 'drv'.

. Create a `field` node as child of `record:drv`, name it 'x' and again set the type to `Double`.

Note that the names 'drv' and 'cnt' don't imply any meaning to the specifications - they're just names. Their _roles_ as drivers and constants will be defined later. 

This is all the data required for this tutorial.  The task to add a `dataDefinition` node has now gone and three tasks remain.

===== Dynamics

The `dynamics` sub-tree specifies how the modelled system will evolve over time. It determines the temporal order of function calls, their type, the conditions under which the simulation will stop and what and when data will be tracked for for output. 

In the present case, the first task is to call the logistic equation a set number of times and provide the result from the previous time step to the equation at the current time step. 

The `dynamics` sub-tree is a child of the `system` node - the root of the modelled system that defines both its dynamics and its structure. To begin defining the system dynamics, create a `system` node and then a `dynamics` node as its child.

. Right-click on the root node (`3worlds:Tut1`) and select `New node -> system` from the popup menu. 

The addition of the `system` node has removed one task (to add a `system`) and added four more. One of these tasks is to add a `dynamics` node.

[start = 2]

. Add a `dynamics` node as a child of `system:sys1`.

This node (lime green) is the root of the dynamics sub-tree and when the specifications are run, this node is the specification of a type of simulator. There can be many simulators of this specification running in parallel depending on the experimental design.

In the `dynamics` sub-tree, we now proceed to create `timeline`, `timer`, `process` and `function` nodes.

[start =3]

. From the `dynamics` node create a `timeline`. The timeline defines the type of time scale used in this dynamics sub-tree. 

There are ten different types of time scale available: all of them exact sub-divisions of time except for the Gregorian scale type which implements the standard Gregorian calendar. The default is `ARBITRARY` which is fine for this tutorial. 

There is now a new task to add a `timer` node to the `timeline`.

[start = 4]

. Create a `timer` as a child of `timeline`. Here an extra prompt appears asking for the class of the timer: {`ClockTimer`, `EventTimer`, `ScenarioTimer`}. Select `ClockTimer`. This timer class increments time by a constant step during simulation, unless the timeline uses a Gregorian scale in which case irregularities such as leap years are managed. 

There is now a new type of task indicating that a property value for the new timer is incorrect: `[Property] ['[Property:dt=0]' does not satisfy '[Property 'dt=0' must be within [1.0; 9.223372036854776E18].]']`. This just means the value of `dt` (delta time) must be >= 1.

[start=5]

. In the property editor, change `tmr1#dt` to 1, whereupon a new task appears saying the same thing for `tmr1#nTimeUnits` so set that to 1 as well. 

`dt` is the time unit size and `nTimeUnits` is the number of time units per simulation step. There are 22 time unit types available ranging from microseconds to millennia. The current default value of `UNSPECIFIED` is fine for this tutorial - time here is just a sequence of steps. 

Note that a model can have any number of `timers` using any of the available time steps and time units as long as the time units selected are compatible with the parent `timeline`. The task messages will indicate if this is not the case. Because the specifications allow for more than one system, it follows there can be many dynamics sub-trees, each with their own time system. (*can we really do this?*)

A new task has been posted requiring a `process` node.

[start = 6]

. Create a process node as child of `timer:tmr1`. 

A `process` defines a set of computations acting on model components driven at the rate of the parent `timer`. A `component` is definition of a unit of simulation. It can be any physical or biology entity represented in the model that has dynamic behaviour (plants, animals, nutrient pools, lakes, the atmosphere or the rhizosphere etc).

Processes can be composed of any number of functions of various types (much more on this later). We need just one function to implement the logistic equation - a `ChangeState` function that takes the current state of a component and calculates the next state.

[start = 7]

. Create a `function` as a child of `process:p1`, name it `Chaos` and select `ChangeState` as its type.


The function type can't be changed after creating node, so if you make a mistake, delete and recreate it (`Delete` from the popup menu or `Undo` from the main menu).

_ModelMaker_ can link to an Integrated Development Environment (IDE) such as _Eclipse_, to write code for these functions. In this tutorial the funcion is one line of code and we can just associate a code snippet with the function without the need to link to an IDE. The snippet will be inserted in the function when the simulation is compiled.

[start = 8]

. Create a `snippet` node as a child of `function:Chaos`. 

. In the property editor, locate the `snpt1#javaCode` property, click the edit button ('*...*') and enter the following text:
`focalDrv.x = r*x*(1-x);`


===== Structure

The `structure` sub-tree describes how the modelled system is organised into separate `components` playing particular roles. In an elaborate model, there can be many `components` but in the present case, we need only one, and for convenience, the `system` node can act as this single `component` without the necessity of actually creating a `component` within a `structure` sub-tree. 

Here, the component's _role_ is defined as:

- lifetime: _permanent_; 

- organisation: _atomic_ 

- category: _arena_. 

- It uses _r_ as a constant and _x_ as a driver; and,

- `process:p1` applies to it. 

The component is _permanent_ because it doesn't die, it's an _atomic_ simply because it is a single indivisable component, residing in an _arena_ because, well, everything's got to be somewhere. No matter how many components a model has, exactly one of them must belong to the _arena_ category, a unique top level component - its more or less a global component accessible to all other components. 

While this is complicated for such a simple function, later tutorials will show how this can be a powerful approach to structuring any complex hierarchical dynamic system composed of interacting physical and biological components. 

To create this role, we use nodes of the type `categorySet` and `category`. A `categorySet` is a set of mutually exclusive categories. By that we mean a `component` can only be associated with one category of a given categorySet. So for example _permanent_ and _ephemeral_  are two categories within a set called _lifespan_ and obviously, a component can only be one or the other. Categories and CategorySets are recursive: a CategerySet contains Categories and Categories can contain CategorySets without limit. 

Apart from the `system` node doubling as a `component`, an additional convenience is provided: a sub-tree of predefined category sets and categories. We use these nodes to define the role described above. To see this sub-tree:

[start=8]

. Right-click on the root node and select `Collapse -> All`.

. Right-click again on the root node and select `Expand -> predefined:*categories*`.

. Re-apply the layout ('*L*')

The `predefined:*categories*` sub-tree is created with every new project (collapsed by default) and is _immutable_ apart from allowing edges to be added between it and other sub-trees.

There are two `record` nodes within this sub-tree for default handling of average population and ephemeral data. Since the single component used here will be neither of these we can ignore this section:

[start = 11]

. Right-click on `predefined:*categories*` and collapse both the `AVPopulation` and `AVEphemeral` sub-trees.

. Right-click on the root node, expand the `system` and re-apply the layout.

We are now in a position to define the _role_ of the `system` node (a.k.a. `component` in this case).

[start = 13]

. Right-click on `system:sys1` and select `New edge -> belongsTo -> category:*arena*`.

. Right-click on `system:sys1` and select `New edge -> belongsTo -> category:*atomic*`.

. Right-click on `system:sys1` and select `New edge -> belongsTo -> category:*permanent*`.

The above edits have created three _cross-link_ edges. All _cross-links_ are red - thin at the _start node_ and thick at the _end node_. Unlike parent-child links, they have names. Generally, the names of _cross links_ are not much use. They can be hidden by selecting the drop-down list `E text` at the bottom of the Graph display, and selecting `Role`. The relationship can be read as, for example: `system:sys1 belongs to category:*arena*`.

Finally, we need to apply `process:p` to a category - in this case, the _arena_.

[start = 16]

. Right-click on `process:p1` and select `New edge -> appliesTo -> category:*arena*`.

There are now two tasks remaining in the task list: the experimental design and the user interface.


===== Experiment sub-tree

We now specify the simplest possible experiment: a single run of the model.

. Collpase the `predefined` sub-tree from the root node and re-apply the layout.

. Create an `experiment` as a child of the root.

. Create a `design` as a child of `experiment:expt` and when prompted, select the `type` property. 

Experimental designs can take many forms including predefined types such as `crossFactorial` or designs read from a file. For now we just use a predefined `type` with its default value of `singleRun`.

===== User interface sub-tree

The minimum requirement for a user interface is a controller widget: something that can start and stop a simulation. Of course, we'll also need to display the value of _x_ with, say, a time series chart. This can be added later after trying out the simulator. 

Simulations can also run without any graphical user interface - they still must have a user interface but it need not be visible. This situation is called a 'headless' simulator and can be used on unsupervised systems or systems where a user interface is not possible.

When the simulation is run, its graphical user interface has optionally, a toolbar at the top, a status bar at the bottom and any number of tabs containing any number of widgets. The controller must be placed either in the toolbar or status bar. Here we place it in the toolbar.

. Collapse `experiment:expt` from the root node.

. Create a `userInterface` as a child of the root.

. Create a `top` as a child of `userInterface:gui`.

. Create a `widget` as a child of `top:top1`, name it 'ctrl' and select `SimpleControlWidget1` from the drop-down list as its class.

The model specifications now comply with the archetype and the code has compiled. Save your work (`Ctrl+s`) and the task list will be empty. The *Deploy* button is now enabled and the traffic light has changed from red to green (bottom left corner of _ModelMaker_).

In addition, the specifications have been automatically documented by the production of an ODD template (Overview, Design concepts and Details) (`Tut1.odt`), an established standard for documenting simulation models. This file is always generated after every edit of a valid specification. When you are statisfied with the specifications, make a copy of this file as a basis for the complete documenting of the model. 

NB: If you edit the file without making a copy, those edits will be lost whenever the specifications are modified.  

===== Deployment: launching _ModelRunner_

. Click the `Deploy` button. _ModelMaker_ now launches _ModelRunner_ to start the run-time application: _ModelRunner_. 

At the top of _ModelRunner_ are some control buttons to start, step and stop the simulation. This is the `SimpleControlWidget1` we added above. The _run_ button becomes a _pause_ button while running and the _stop_ button resets the simulator to its starting state. 

However, as expected, there's nothing to see so the next step is to add a time series widget. This is an optional requirement so the task list didn't complain about this. 

You can move easily between design and execution of the specifications simply by deploying _ModelRunner_, checking the simulation and quitting to return to _ModelMaker_.

To add a time series for _x_:

[start = 2]

. Quit _ModelRunner_ and return to _ModelMaker_.

. Create a `tab` node from the  `userInterface:gui` node. 

. Create a `widget` node from `tab:tab1`, name it 'srsx' and select `SimpleTimeSeriesWidget` from the drop-down list. 

A new task has been added to the list requiring an edge from this widget to a dataTracker. 

For this widget to receive values of _x_, something must post values of _x_ to the widget at the same rate as the `Chaos` function is executed. This is the job of a `dataTracker` and it properly belongs in the `dynamics` sub-tree. 

[start = 5]

. Create a `dataTracker` as a child of `process:p1` and choose `DataTrackerD0` as it class. This class of data tracker is suitable for scalar data as is the case with _x_.

. Create an edge from the `dataTracker` to _x_ by selecting `New edge -> trackField - > field:x`. 

Visually, something different happened this time: the edge appeared and then faded away. This is a gesture to indicate that the edge was created but since the end node is not visible (this would be the case if you we following these steps exactly), it fades away to keep the graph display neat and tidy.

. Create an edge from `widget:srsx` to the new data tracker.

. Create an edge from `dataTracker:trk1` to a `component` i.e in this case `system.sys1`. A data tracker must not only track some data but also the `component` that uses this data. However, from the task list it can be seen that _x_ and _r_ are not part of the _role_ defined for `system.sys1`. To do this, we categorise _x_ as a _driver_ and _r_ as a _constant_. The appropriate category belonging to `system:sys1` is the `category:*arena*`. Before doing this we can tidy up the display and practice a little fiddling with the collapse/expand functions by showing just the nodes we're concerned with for defining the roles of _x_ and _r_:

. Collapse the all sub-trees from the root node.

. Expand the `predefined:*categories*` sub-tree.

. Collapse `All` from the `predefined:*categories*` sub-tree.

. Expand `categorySet:*systemElements*` from `predefined:*categories*` node.

. Collapse `All` from `categorySet:*systemElements*`.

. Expand `category:*arena*` from `categorySet:*systemElements*`

. Finally, expand `dataDefinition:dDef` from the root node and re-apply the layout.

To create the _roles_ for _x_ and _r_:

. From `category:*arena*` select `New edge -> constants -> record:r`

. Again from `category:*arena*` select `New edge ->drivers -> record:x`


. Save the graph (`Ctrl+s`). 

The task list should be empty and the simulation can be re-deployed.
 
===== Stopping conditions 

If you examine the graph and all its properties, you may notice that there is no indication as to how long the simulation should run. This means that when we run it we should expect it to continue indefinitely. You may or may not want this. If your model contains an unconstrained exponential function, it may eventually crash unless your code takes measures to handle this. You can add a variety of simple or complicated stopping conditions to the `dynamics` node. These will be discussed in later tutorials.

When we first ran this model it had no output. Now that we have a time series chart, displaying data of unlimited length will make the _ModelRunner_ fairly unresponsive. If you press the run button and then the stop or pause button it may take a while for the model to actually stop running. So for now, it's best to test the simulation with the `Step` button.
[start =6]

. Deploy _ModelRunner_ (saving first if prompted)

. Click the `step` button a few times. A time series of zeros is shown. 

. Click the `run` button twice in rapid succession. The time (x axis) now reads approximately 30,000 or so depending on the speed of your computer.

The display is still uninteresting because we haven't set an initial value for _x_ or parameterised _r_. This can be done in a number of ways but for this tutorial we will add an initialisation function and a code snippet. We will also include a `stoppingCondition`.

[start=9]

. Quit _ModelRunner_ and return to _ModelMaker_.

. Collapse all sub-trees from the root node and expand just the `system:sys1` sub-tree.

. Create an `initFunction` as a child of `system:sys1`.

. Create a `snippet` as a child of `initFunction:Init1`.

. Enter the following two lines in the `snpt2#javaCode` property:
  ... `focalDrv.x = 0.001;`
  ... `focalCnt.r = 3.7;`

If you make a typo, the task list will show the details of the compile error.

To complete this tutorial, add a simple stopping condition:

[start = 14]

. Create a `stoppingCondition` as a child of `dynamics:sim1`. When prompted, select `SimpleStoppingCondition` from the drop-down list.

. Select this new node and in the properties editor, set the value of `stCd1#endTime` to 100.

. Save, re-deploy and run the simulation. You'll now see a time series of the chaos function of 100 time steps.


==== Graph layouts

An aspect of _ModelMaker_ we have only touched on so far, is the graph layout system.

While using a graph to construct model specifications has many advantages, you can quickly become lost in a confusion of nodes and edges. The advantage in using a graph is that the huge number of options possible can be constrained by context. For example, to have a dynamic `process`, it makes sense that it's associated with a particular `timer`, that other processes working at the same rate are associated with the same `timer` and that all timers are coordinated by the one `timeline`. The user interface for problems such as this would be very error-prone if presented say, as a series of dialog boxes.

_ModelMaker_ has a number of features to help arrange the graph display. These fall into three categories: arranging, hiding and resizing.

*Arranging*: There are five layout algorithms currently available in _ModelMaker_ of which three use the tree structure of the graph to arrange nodes and two are 'Spring' based algorithms. Tree methods are ideal for examining the parent-child structure while the last two are better suited to examining relations between nodes. Tree methods are deterministic while Spring methods are not. Thus, Tree methods are better for maintaining your orientation to the graph but have the disadvantage of not arranging cross-link edges clearly. Spring methods do a better job of this but the resulting arrangement can change with each application of the layout.

Two of the Tree methods produce a radial layout. These are best suited to examining nodes that have many children such as a record with many fields.

All Tree methods allow selecting any node as the root of the tree. This is achieved from the popup menu of each node. When the 're-apply layout' button is pressed ('*L*') while using a Tree method, the root of the tree becomes is the root of the graph (`3worlds:Tut1`).

When a project is first created, the default layout is an *orderedTree*. To change to other layouts, use the local popup menu for any node. This layout persists for repeated applications of the layout function until another is chosen.

You can add a random displacement to nodes to help prevent node and edge text overlapping. This setting is applied whenever the layout is re-applied.

Finally, you can of course move a node anywhere within the graph window. 

*Information hiding*: The following operations can help to hide temporally irrelevent information:

- *collapse/expand*: You can hide or show sub-trees from any node from its local popup menu. In addition, all properties of collapsed sub-trees and removed from the property editor;
- *X* Show/hide cross-link edges. 
- *<* Show/hide parent-child edges.
- *>|* Move all isolated nodes to one side (after re-applying the layout)
- *Show neighbourhood*:  With this feature, you can choose to show only nodes within a given path distance from a selected node.
- *A*: Show all nodes. That is, undo the above operation.
- change the node and edge text this is displayed with the `N-text` and `E-text` drop-down lists.

*Resizing*:

- *Zoom*: Zoom in and out in the graph window with the mouse pointer as the focus point (`Ctrl - mouse wheel`)
- *Pan*: If the drawing surface is larger than the window, you can drag the drawing surface of the graph window (left click outside a node)
- *Node Size*
- *Font size*

You can also change font sizes, node sizes and, as noted, the node and edge names by hiding or showing either or both roles and names.
 
As an exercise if you wish, try displaying just the nodes with _cross links_ using the SpringGraph layout. This is a common way to look at just the _cross link_ relationships between nodes. Generally, adding a screen capture of this and a second screen capture of just _parent-child_ relationships make useful additions to the ODD appendix.

. Expand all sub-trees from the root node.

. Collapse `record:AVPopulation` and `record:AVEphemeral` from `predefined:*categories*` (these edges are irrelevant here).

. Hide all parent-child lines ('*<*').

. Set isolated nodes to be moved to one side when layout is next applied ('*>|*').

. Right-click on any node and select `Apply layout -> SpringGraph`.

That's the end of this tutorial. Recreate this project at anytime from the main menu (`Project -> New -> Tutorials -> 1 Logistic`).

==== Next

The next tutorial (Tutorial 2) will demonstrate linking this project to an IDE and adding some Java program code.

