===== The representation of time

Simulation is about mimicking the dynamics of a real system. Here, dynamics is specified by attaching particular behaviours (called processes) to either categories or relations. Processes may act at a different rhythm or rate in nature, so we need to have a great flexibility in the way time is represented.

====== Time line

`/3worlds/system/dynamics/*timeLine*:<[underline]##__name__##>` {1}

Every simulator has a reference _time line_. Since different ecological processes may run according to different time models, they must refer to a common time frame for interaction to be possible among them. A `*timeLine*` defines what kind of time scale and time units can be used in a simulation. In 3Worlds, time is always discrete in the end, so that the selected values of time scale and time unit define the time _grain_ of the simulation, i.e. the duration below which events are considered simultaneous. Internally, the `ModelRunner` uses integers to represent time, with 1 = one time grain.

include::ArchetypeDoc-timeLine.adoc[]

====== Time models

`/3worlds/system/dynamics/timeLine/*timeModel*:<[underline]##__name__##>` {1..*}

Ecological processes may be run following different time models. A time model is a particular way of representing time in the simulator. Time models may differ in parameters, like e.g. two time models using different time steps; but they can also be radically different in their logic: e.g. clock-like ticking vs. event-driven simulation.

include::ArchetypeDoc-timeModel.adoc[]

`class`:: the type of `timeModel` to use.
+
****
_possible values_:

[horizontal]
`ClockTimeModel`:: Time is incremented by a constant amount _dt_. This is commonly used to simulate regular processes like growth.
`EventTimeModel`:: Model dynamics generates _events_ and computes the date in the future at which they are going to occur. This is commonly used to generate irregular processes like fire occurrence.
`ScenarioTimeModel`:: *Not yet implemented*.
****

_Additional properties when_ `class = ClockTimeModel`

[horizontal]
`dt`:: The constant time increment used in this `ClockTimeModel`, expressed as an integer number of `TimeModel` base unit (=`TimeModel.nTimeUnits` x `TimeModel.timeUnit`). For example, if the TimeModel has `timeUnit` = `DAY` and `nTimeUnits` = 3, `dt` is expressed in units of 3 days (e.g. `dt` = 2 means the time increment is 6 days).
+
WARNING: if calendar time is used (`timeLine.scale` = `GREGORIAN`), then `dt` will sometimes not be constant (e.g. if `dt` = 2 `MONTH`, `dt` will vary in duration between 28 and 31 days according to the exact date).

_Additional sub-tree when_ `class = EventTimeModel`

`/3worlds/system/dynamics/timeLine/timeModel/*eventQueue*:<[underline]##__name__##>` {1}

An `EventTimeModel` maintains a queue of time events that gets populated by ecological processes. Time events are stored in this queue based on their date and activated by the simulator following time order.

// NB: is this maintained?
_Cross-links for_ `eventQueue`

`populatedBy -> function:<[underline]##__name__##>` {1..*}::
These links indicate which ecological processes will populate the event queue with time events.

====== Simulation stopping condition

`/3worlds/system/dynamics/*stoppingCondition*:<[underline]##__name__##>` {0..*}

A simulation may be run indefinitely (interactively), but in big simulation experiment it is useful to automatically stop the simulations according to some criterion. Besides the simplest stopping condition, reaching a maximal time value, 3Worlds provides many other possibilities to stop a simulation (e.g. based on a population size, on a variable passing a threshold value, etc.).

When no stopping condition is defined, the simulation will run indefinitely.

_Properties for_ `stoppingCondition`

[horizontal]
`class`:: The type of stopping condition to use
+
****
_possible values_:

`SimpleStoppingCondition`:: 
Simulation stops when a maximal time value is reached.
`ValueStoppingCondition`:: 
Simulation stops when a variable in a reference system component is reached.
`InRangeStoppingCondition`:: 
Simulation stops when a variable in a reference system gets within the given range.
`OutRangeStoppingCondition`:: 
Simulation stops when a variable in a reference system gets out of the given range.
`MultipleOrStoppingCondition`:: 
Compound stopping condition: simulation stops when _any_ of the elementary stopping conditions within this multiple condition's list is true.
`MultipleAndStoppingCondition`:: 
Compound stopping condition: simulation stops when _all_ of the elementary stopping conditions within this multiple condition's list are true.
****

_Additional properties when_ `class = SimpleStoppingCondition`

[horizontal]
`endTime`:: The time at which the simulation will stop, in time line `shortestTimeUnits`.

_Additional cross-links when_ `class = ValueStoppingCondition`, `InRangeStoppingCondition`,  `OutRangeStoppingCondition`

`stopSystem -> component:<[underline]##__name__##>` {1}::
The system component in which the criterion variable will be checked to stop the simulation.

_Additional properties when_ `class = ValueStoppingCondition`

[horizontal]
`stopValue`:: The value of `stopVariable` at which to stop the simulation.

_Additional properties when_ `class = InRangeStoppingCondition`, `OutRangeStoppingCondition`

[horizontal]
`upper`:: The upper value of the `stopVariable` range. Only `double` values are accepted.
`lower`:: The lower value of the `stopVariable` range. Only `double` values are accepted.

_Additional cross-links when_ `class = MultipleOrStoppingCondition`, `MultipleAndStoppingCondition`

`condition -> stoppingCondition:<[underline]##__name__##>` {1}::
These links point to the stopping conditions that will be used as elementary stopping conditions by the multiple and/or stopping condition.

===== The transformations of a system component

Changes in a _system component_ through time may be of different kinds: changes in __state__, i.e. in its driver and decorator variables; or more radical changes where the component actually changes __category__, so becomes represented by a different set of variables. Plus, a component may have an ephemeral life (lifespan property), which means component objects are dynamically created or deleted during a simulation.

To represent category changes, start and end of life, we need the concept of a __life cycle__: a series of successive discrete states decribed by different categories (starting  from non-existence and finishing alike). Notice that the life cycle is optional: if a system component is going to be represented by the same set of variables (same category) during its whole life, there is no need to attach a life cycle to it as there will be no transition to other categories.

====== Life cycle

`/3worlds/system/dynamics/*lifeCycle*:<[underline]##__name__##>` {0..*}


===== Ecological processes

====== Process

`/3worlds/system/dynamics/timeLine/timeModel/*process*:<[underline]##__name__##>` {1..*}

_Processes_ are used in 3Worlds to compute change in _system components_. Each process acts on system components of a particular group of categories (cf. <<truecategory,Category>>, <<truesystem-component,System Component>>) and is scheduled by a particular time model (cf. <<truetime-representation,time representation>>). Processes contain user-defined code that represents ecological processes. This gives 3Worlds its versatility: one can mix in a single model completely different ecological entities (system components of different categories), implement any ecological process depending on user needs, and put them to work on different time scales (time models). A `process` is run according to its parent `timeModel`.

_Cross-links for_ `process`

A process can act on a single system component at a time (called the _focal_ system component), or on a pair of components linked by a relation (called the _focal_ and the _other_ system components). This is specified using the `appliesTo` cross-link (one at least must be present):

`appliesTo -> category:<[underline]##__name__##>` {0..*}::
These links indicate the categories of system components that will be acted on by the process.
`appliesTo -> relation:<[underline]##__name__##>` {0..1}::
This link indicates to which relation type between system component the process applies.
`dependsOn -> process:<[underline]##__name__##>` {0..*}::
This link tells that the process must be activated _after_ the processes targeted by the links. Use this link to organize computations when there are dependencies between them.

====== Function

`/3worlds/system/dynamics/timeLine/timeModel/*function*:<[underline]##__name__##>` {1..*}

This node is used to specify the details of the computations made in a `process`. The `process` defines which system components are going to be activated and at what time in the simulation course; the `function` defines which computations, in detail, will be applied to the system components of that process. This enables to build complex computations applying to one component (a series of ``function``s within a `process`) in the context of a particular subset of components (`process`).

There are different types of functions, differing by the way they affect system components and relations. This is specified by setting the `type` property to the desired function type.

include::ArchetypeDoc-function.adoc[]

The selection of a function type will trigger the generation of a java source file *[WHERE?]* for a class having the name specified in the `function` node name.

CAUTION: The name of a function must be a valid java class name, starting with an uppercase letter.

This java source file is expected to be edited by the modeller in order to implement her/his favourite version of the ecological process modelled by the function. 


====== Function consequences

`/3worlds/.../process/function/*consequence*:<[underline]##__name__##>` {0..*}

Some functions may imply consequences: for example, a decision to delete another system component may be followed by a change in state based on the deleting component's state at the time it is deleted. Such functions that are only activated when certain events take place are called _consequences_ and may be specified by a child node to a function. Here also, rules apply:

[width="100%",options="header",cols="1,1,2"]
|====================
| function | consequence  |  use to
| `changeState` |  |  
| `changeRelationState` | |
| `changeOtherState` |  |
| `deleteDecision` .2+| `changeOtherState`  .2+|  carry over values to another component linked by a `returnsTo` relation
| `deleteOtherDecision`
.3+| `createOtherDecision` | `changeState` |  set the initial state of the new component
|  `changeOtherState` |  set values to the new component according to parent  (_focal_) state
|  `relateToDecision` |  set a `parentTo` relation between new component and parent
| `changeCategoryDecision` .2+| `changeOtherState` .2+|  carry over and compute values from the former component (__focal__) to the new recruit
| `changeOtherCategoryDecision`
| `maintainRelationDecision` |  |  
| `relateToDecision` |  |  
|====================

====== Data tracking

*[TO DO]*

===== The setup of an initial state for a simulation

// WARNING: this section is under dynamics, but maybe it's not the best place to put it.
*[TO DO: check the consistency of all this]*

====== Initial state

`/3worlds/system/dynamics/*initialState*:<__name__>` {0..1}

To run a simulation, an initial population of `components` must be provided. Nodes under the `initialState` node are used to input data to create such an initial state. The initial state is kept in memory by the simulator, and is re-loaded at every reset prior to a new simulation of the simulator.

// IMPORTANT: Please note that 3Worlds allows for five different ways of initialising a simulation. These methods are explained in detail in section <<truefeeding-the-model-with-data,feeding the system with data>>).

====== Group

`/3worlds/.../initialState/*group*:<__name__>` {0..*}

Initial system components belong to groups of individual components with common characteristics. A group is either:

. a number of components that share the same selection of categories and the same parameter set

. or a group of previous type groups (1), belonging to the same life cycle.

_Cross-links for_ `group`:

`groupOf -> component:<__name__>` {0..1}::
This link tells which `component` node defines the individual components of this group (type 1 above).

`cycle -> lifeCycle:<__name__>` {0..1}::
This link tells which `lifeCycle` node defines the grouping of 'groupOf'-type groups (type 2 above).

CAUTION: Exactly one of these cross-links must be present for every group.

Type (1) groups may be nested into type (2) groups, i.e.:

`/3worlds/.../initialState/group/*group*:<__name__>` {1..*}

====== Individual

`/3worlds/.../initialState/**individual**:<__name__>` {0..*}

`/3worlds/.../initialState/group/**individual**:<__name__>` {0..*}

`/3worlds/.../initialState/group/group/**individual**:<__name__>` {0..*}

This node specifies an instance of a _system component_ to be created at the beginning of a simulation.

_Cross-links for_ `individual`:

`instanceOf -> component:<__name__>` {0..1}::
This link tells which `component` node defines this individual component.

====== Parameters

Parameter sets define a group: they are constant values which are shared by all individual members of a group.

`/3worlds/.../initialState/**parameterValues**:<__name__>` {0..*}

Use this node to attach a set of parameters to the whole ecosystem. There will be only one of such parameter sets in any given simulator. In user-defined functions, these parameters are available through the `focalContext.ecosystemParameters` field.

CAUTION: all focalContext fields may be null if no value was provided at initialisation. Any user-edited function code must check for this possibility when using these fields.

`/3worlds/.../group/**parameterValues**:<__name__>` {0..*}

Use this node to attach a set of parameters to a group. Each different `__name__` will create a different parameter set. Depending on the group type, these parameters are available through `focalContext.lifeCycleParameters` of `focalContext.groupParameters` in the user-defined functions.

`/3worlds/.../component/**parameterValues**:<__name__>` {0..*}

Use this node to attach a set of parameters to an individual system component. 

CAUTION: this implies that this system component is unique of its kind, and no other component is allowed to share these parameter values.

*[TODO: check this is not a flaw - how do we access these parameters ?]*

====== Variables

`/3worlds/.../component/**variableValues**:<__name__>` {0..*}

Use this node to attach a set of initial driver values to an individual system component. A new component will be created for every different value of `__name__`.

*[TO DO: loading from files...]*

