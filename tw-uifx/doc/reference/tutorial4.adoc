=== Elaborating the model structure: Testing the Intermediate Disturbance Hypothesis

==== Introduction

In this tutorial we add a disturbance to effect a community of plants modelled with the competitive Lotka-Volterra equation (CLV) from Tutorial 3. With this model, we can examine the Intermediate Disturbance Hypothesis (IDH). 

==== Specifications

Begin this tutorial using the Lotka-Volterra specifications from the `Tutorials` menu as a starting point.

. Create a new project from on `Tutorials -> 2 LotkaVolterra` and name it 'Tut4'.

===== Data definition

. Collapse all nodes except for the `dataDefinition` sub-tree, hide the _cross-links_ ('*X*' button), and re-apply the layout ('*L*' button).

. Add a new `record` as a child of `dataDefinition:dDef` and name it 'dec'.

Data is divided into three classes in the _3Worlds archetype_:

... _constants_ (cst), 

... _drivers_ (drv) and 

... _decorators_ (dec). 

Decorators are values derived from the current value of the drivers. Here, the _decorator_  will be a species diversity index (Shannon's), derived from relative abundance of each species. 

As noted previously, these names are just for clarity - they don't impose a _role_. You can name a node any thing you like as long as the names are unique. Here, the records are named to align with their intended roles to keep things organised. The _role_ is formally defined when these records are later collected together within a `category` that `belongsTo` a `component`.

. Add a `field` as a child of `record:dec`, name it 'div' (diversity index) of type `Double`.

We now define some data for the simple disturbance model: frequency and intensity.

. Add a new `record` to `dataDefinition:dDef` and name it 'distCst' (disturbance constants).

. Add two fields to this record, both of type `Double` called 'freq' and 'inten' respectively. 

The previously defined records should now be given better names. A trick with the Tree layout functions is that they order the trees alphbetically. To arrange nodes so that related nodes of a particular role are close together, prefix the name with the same string - in this case 'dist'. We could name all the data associated with the CLV with 'comm' (community).

. Rename `record:cst` to `record:commCst`, `record:drv` to `record:commDrv` and `record:dec` to `record:commDec`.

. Re-apply the layout. The data fields should now be in a more sensible order.

Fill out the meta-data properties with at least the desciption of the data. As mentioned, these descriptions are incorporated in the comments of the generated Java code.

Add the following descriptions to the new data defintions:

- `freq#description`: 'average return time'
- `inten#description:`'% population decrease'
- `div#description:` 'shannon diversity'

For simplicity, we define intensity as a constant rather than a driver.

That's all the data needed for this tutorial and the task list should now be empty.

===== Dynamics

In this section we add a function to initiate a disturbance and second to apply the disturbance to the community.

. Collapse all sub-trees and expand `system:sys1`.

. Create a `process` as child of `timer:clock1` and name it 'procDistOccurance`.

. Create a `function` as child of `process:procDistOccurrence` and name it 'DistOccurrence' and set its type as `RelateToDecision`.

. Create a second `process` as child of `timer:clock1` and name it 'procDistEffects'.

. Create a `function` as child of `process:procDistEffects`, name it 'DistEffects' and set its type to `ChangeOtherState`.

The name the growth process and function should now be changed to something more appropriate:

[start = 6]

. Rename `process:p1` to `process:procCommGrowth`.

. Rename `function:Growth` to `function:CommGrowth`.

The function `function:CommGrowth` will perform the same function as it did in the previous tutorial: calculate the next state of _x_ from its current state. 

The function `function:DistOccurrence`, a `RelateToDecision` function, will decide if a disturbance is to occur or not. 

If a disturbance occurs, `function:DistEffects` will implement the consequences of the disturbance on the community.

This implies an order of execution of these three functions. As all these functions are driven by the same `timer` and therefore occur simulateously, it means we must make the calling order explict. To do this we add an edge saying 'X depends on Y'.

First, set `process:procDistEffects`to depend on `process:procDistOccurrence`.

[start=8]

. Right-click on `process:procDistEffects` and select `New edge -> dependsOn -> process:procDistOccurrence.

To be consistence in the order, make `process:procCommGrowth` depend on `process:procDistEffects`.

[start = 9]

. Right-click on `process:procCommGrowth` and select `New edge -> dependsOn -> process:procDistEffects`.

That's all that's required in this section. The task list indicates that the new processes must belong to some categories. To do that we need to move on to the structure of the specifications.

===== Structure

Recall from the previous tutorial, that `system:sys1` is acting as a single component. It's _role_ was defined as:

... _permanent_;

... _individual_; 

... belongs to the _arena_; 

... accessing particular data from the `dataDefinition` sub-tree; and,

... has `process:p1` applied to it.

The _arena_ is a special category. It must exist in every specification and can only have data  (_constants_, _drivers_ and _decorators_) associated with it if it belongs to `category:individual`. With the addition of disturbance there will now be multiple components associated with the _arena_ so it must be categorised as a `population`(?) and can no longer have data. If it were allowed to have data, the data would be available to all functions. This would imply a relationshipe between functions that would not be apparent from the specifications. 

The _role_ of a `component` is defined by its `componentType`. We'll need two `ComponentTypes`; one for the community (the CLV equation) and one for the disturbance. We also need a `relationType` to define a _role_ to associate the disturbance with the effected community.

. Create a `structure` as a child of `system:sys1`.

. Delete `initFunction:init` as it's not needed for these specifications.

. Create a `componentType` as a child of `structure:struc1` and name it 'distType'.

. Create a `component` as child of `componentType:distType` and name it 'dist'.

. Create a second `componentType` as child of `structure:struc1` and name it 'commType'.

. Create a `component` as child of `componentType:commType` and name it 'comm'.

. Create a `relationType` as child of `structure:struc1` and name it 'distToComm'.

We now define the _roles_ of the two `componentTypes`, and what categories are related by the `relationType`. But first we should redefine the _role_ of `system:sys` that we inherited from Tutorial 3 when starting this project.











.






==== Next

