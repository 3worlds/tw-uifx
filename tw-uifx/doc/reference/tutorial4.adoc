=== Elaborating the model structure: Testing the Intermediate Disturbance Hypothesis

==== Introduction

In this tutorial we add a disturbance to effect a community of species modelled with the competitive Lotka-Volterra equation (CLV) from Tutorial 3. This model could be used to examine the Intermediate Disturbance Hypothesis (IDH). 

==== Specifications

Begin this tutorial using the Lotka-Volterra specifications from the `Tutorials` menu as a starting point.

. Create a new project from on `Tutorials -> 2 LotkaVolterra` and name it 'Tut4'.

===== Data definition

. Collapse all nodes except for the `dataDefinition` sub-tree, hide the _cross-links_ ('*X*' button), and re-apply the layout ('*L*' button).

. Add a new `record` as a child of `dataDefinition:dDef` and name it 'dec'.

Data is divided into three classes in the _3Worlds archetype_:

... _constants_ (cnt), 

... _drivers_ (drv) and 

... _decorators_ (dec). 

Decorators are values derived from the current value of the drivers. They are set to zero at the beginning of each time step. Here, the _decorator_  will be a species diversity index (Shannon's), derived from relative abundance of each species. 

As noted previously, these names are just for clarity - they don't impose a _role_. You can name a node any thing you like as long as the names are unique. Here, the records are named to indicate their intended roles to keep things organised. The _role_ is formally defined when these records are later collected together within a `category` that `belongsTo` a `component`.

[start = 3]

. Add a `field` as a child of `record:dec`, name it 'div' (diversity index) of type `Double`.

We now define some data for the simple disturbance model: frequency and intensity.

[start = 4]

. Add a new `record` to `dataDefinition:dDef` and name it 'distCnt' (disturbance constants).

. Add two fields to this record, both of type `Double` called 'freq' and 'inten' respectively. 

The records carried over from the previous tutorial should now be given better names. A trick with the Tree layout functions is that they order the trees alphabetically. To arrange nodes so that related nodes of a particular role are close together, prefix the name with the same string - in this case 'dist'. We could name all the data associated with the CLV with 'comm' (community).

[start = 6]

. Rename `record:cnt` to `record:commCnt`, `record:drv` to `record:commDrv` and `record:dec` to `record:commDec`.

. Re-apply the layout. The data fields should now be in a more sensible order.

Fill out the meta-data properties with at least the description of the data as these descriptions will be incorporated in the comments of the generated Java code.

[start = 8]

. Add the following descriptions to the new data definitions properties:

- `freq#description`: 'average return time'
- `inten#description:`'% population decrease'
- `div#description:` 'Shannon diversity'

For simplicity, we define intensity as a constant rather than a driver.

That's all the data needed for this tutorial and the task list should now be empty.

===== Dynamics

In this section we add two new functions: one to initiate a disturbance and second to apply the disturbance to the community.

. Collapse all sub-trees and expand `system:sys1`.

. Create a `process` as child of `timer:clock1` and name it 'procDistOccurrance`.

. Create a `function` as child of `process:procDistOccurrence` and name it 'DistOccurrence' and set its type as `RelateToDecision`.

. Create a second `process` as child of `timer:clock1` and name it 'procDistEffects'.

. Create a `function` as child of `process:procDistEffects`, name it 'DistEffects' and set its type to `ChangeOtherState`.

The name the growth process and function should now be changed to something more appropriate:

[start = 6]

. Rename `process:p1` to `process:procCommGrowth`.

. Rename `function:Growth` to `function:CommGrowth`.

`function:CommGrowth` will perform the same task as it did in the previous tutorial: calculate the next state of _x_ from its current state. 

`function:DistOccurrence`, a `RelateToDecision` function, will decide if a disturbance is to occur or not. 

If a disturbance occurs, `function:DistEffects` will implement the consequences of the disturbance on the community.

This implies an order of execution of these three functions. As all these functions are driven by the same `timer` and therefore occur simultaneously, it means we must make the calling order explicit. To do this we add a `dependsOn` edge between the relevant processes.

First, set `process:procDistEffects` to depend on `process:procDistOccurrence`.

[start=8]

. Right-click on `process:procDistEffects` and select `New edge -> dependsOn -> process:procDistOccurrence`.

To force the disturbance effects to take place before the community growth, make `process:procCommGrowth` depend on `process:procDistEffects`.

[start = 9]

. Right-click on `process:procCommGrowth` and select `New edge -> dependsOn -> process:procDistEffects`.

That's all that's required in this section. The task list indicates that the new processes must belong to some categories. To do that we need to move on to the structure of the specifications.

===== Structure

Recall from the previous tutorial, that `system:sys1` is acting as a single component. It's _role_ was defined as:

... _permanent_;

... _atomic_; 

... belonging to the _arena_; 

... accessing particular data from the `dataDefinition` sub-tree; and,

... has `process:p1` applied to it.

The _arena_ is a special category. It must exist in every specification. Any data associated with it (_constants_, _drivers_ and _decorators_) is available to all `functions`: the data is global. 

The _role_ of a `component` is defined by its `componentType`. We'll need two `ComponentTypes`; one for the community (the CLV equation) and one for the disturbance. We also need a `relationType` to define the association between the disturbance and the effected community.

. Create a `structure` as child of `system:sys1`.

. Create a `componentType` as a child of `structure:struc1` and name it 'distType'.

. Create a `component` as child of `componentType:distType` and name it 'dist'.

. Create a second `componentType` as child of `structure:struc1` and name it 'commType'.

. Create a `component` as child of `componentType:commType` and name it 'comm'.

. Create a `relationType` as child of `structure:struc1` and name it 'distEffectComm'.

Before proceeding to the definition of the _roles_ of these component types, we should redefine the _role_ of `system:sys1` that we inherited from Tutorial 3 when starting this project.

`system:sys1`, in aliasing as a `componentType`, must now be redefined as an `assemblage` with no functions or data associated with it. 

First, arrange the graph display so only relevant parts are displayed. These instructions are as tedious to write as they are to follow, but its worth it.

[start = 7]

. Collapse all nodes to the root node.

. Expand all nodes from the root node.

. Collapse `experiment:expt` and `userInterface:gui` sub-trees to the root.

. Collapse `dimensioner:nspp` to `dataDefinition:dDef`.

. If you want, you can collapse all `fields` and `tables` into their respective tables.

. Collapse `record:AVPopulation` and `record:AVEphemeral` to `predefined:*categories*`.

. Collapse `category:*group*`, `category:*space*`, `category:*relation*` and `category:*lifecycle*` to `categorySet:*systemElements*`.

. Collapse `dynamics:sim1` from `system.sys1`.

. Re-apply the layout.

Redefine the _role_ of `system:sys1` as an `assemblage`.

[start = 16]

. Right-click on `system:sys1` and select `Delete edge -> belongsTo -> category:*atomic*`.

. Right-click again on `system:sys1` and select `New edge -> belongsTo -> category:*assemblage*`.

Remove the data associated with the _arena_.

[start = 18]

. Right-click on `category:*arena*` and select `Delete edge -> drivers -> record:commDrv`.

. Right-click again on  `category:*arena*` and select `Delete edge -> constants -> record:commCnt`.

`system:sys` is now defined as simply a _permanent assemblage_ belonging to the _arena_.

Now define a `categorySet` to partition data between the disturbance and community. Category sets contain mutually exclusive categories: something can belong to one or the other but not both. Since disturbance and community is all there is in this model, this is the 'world' of the model so this seems a reasonable name for this set of categories. 

[start = 20]

. Create a `categorySet` as child of `structure:struc1` and name it 'world'.

. Create a `category` as child of `categorySet:world` and name it 'distCat'.

. Create another `category` as child of `categorySet:world` and name it 'commCat'.

Define the data for these new categories.

[start = 23]

. Right-click on `category:commCat` and create the following edges:

... `drivers -> record:commDrv`.

... `constants -> record:commCnt`.

... `decorators -> record:commDec`.

. Right-click on `category:commDist` and select `New edge -> constants -> record:distCnt`.


Now define the _roles_ of the new component types for the community and disturbance. Both are _permanent_, atomic_, belong to the _component_ category and access data through their respective categories.

[start = 25]

. Right-click on `componentType:commType` and create `belongsTo` edges to `category:*permanent*`,`category:*atomic*`,`category:*component*` and `category:commCat`. 

. Right-click on `componentType:distType` and create `belongsTo` edges to `category:*permanent*`,`category:*atomic*`,`category:*component*` and `category:distCat`. 

Now define the relation between disturbance and the community.

[start = 27]

. Right-click on `relationType:distEffectComm` and create edges:

... `fromCategory -> distCat`.

... `toCategory -> commCat`.

Finally, add initialisation functions for the disturbance and community component types:

[start = 28]

. Create an `initFunction` as child of `componentType:commType` and name it 'InitComm'.

. Create an `initFunction` as child of `componentType:distType` and name it 'InitDist'.

. Delete `initFunction:Init`. This was carried over from Tutorial 3 as its no longer needed.

That's all that is required in this section. To finish up, we now need to connect various various sub-trees of the graph to each other. Foremost among these is to associate processes with the new structure.

===== Relations between sub-trees

Currently, `process:procCommGrowth` is applied to `category:*arena*`. We want re-apply this process to `category:commCat`.

. Expand `dynamics:sim1` from `system:sys` and re-apply the layout.

. Delete the `appliesTo` edge between `process:procCommGrowth` and `category:*arena*` and re-apply it by creating an `appliesTo` edge to `category:commCat`.

The task list now has two tasks: to connect both disturbance processes to either a `category` or a `relationType`.

[start = 3]

. Create `appliesTo` edges from both `process:procDistEffects` and `process:procDistOccurrence` to `relationType:distEffectComm`.

We have inherited a data tracker from the previous tutorial that tracks the population _x_. We need a second data tracker to follow the species diversity index 'div'. But first we need to ensure the data tracker of _x_ is tracking the correct `component`. Currently, it's tracking `system:sys1` (*and not complaining!*),

. Delete the edge from `dataTracker:trk1` to `system:sys1`.

. Create a `trackComponent` edge from `dataTracker:trk1` to `component:comm`.

. Create a `dataTracker` as child of `process:procCommGrowth` and select the default type `DataTrackerD0`.

. Create a `trackField` edge from `dataTracker:trk2` to `field:div`.

. Create a `trackComponent` edge from `dataTracker:trk2` to `component:comm`.


===== User interface

The specifications have inherited a controller, time series and table for _x_ from the previous tutorial. We just need one more time series to view the species diversity index ('div'). W can take this opportunity to examine a bit more about defining the simulator's user interface.
The `tab` node can contain upto two widgets or two containers that in turn can contain widgets (or a combination of both). What we need then is:

.. tab
... table widget
...    container
.... srs x widget
.... srs diversity widget

This means we need to insert a `container` and set the `widget:srsx` and the new `widget:srsdiv` as children of it. We don't need to delete them and their edges. Instead, we can delete the parent-child link, insert a container and re-establish the parent-child links.

. Expand the `userInterface:gui` sub-tree from the root and re-apply the layout.

. Right-click on `tab:tab1` and select `Delete child edge -> widget:srsx`.

. Create a `container` as child of `tab:tab1`.

. Create a new child edge from `container:cont1` to `widget:srsx`.

. Create a new `widget` as child of `container:cont1`, name it 'srsdiv' and select its class as `SimpleTimeSeriesWIdget`.

. Create a `trackSeries` edge  from `widget:srsdiv` to `dataTracker:trk2`.

The simulation can now be run but, of course, we have yet to add code to the various functions. Here, we'll just add code snippets but if you prefer, you can create a java project and add the code there instead.

===== Java code

. Add a `snippet` to each of the three`functions` and two `initFunctions` in the specifications. Add the following code to the `JavaCode` property of each snippet:

`function:InitComm`:

[source,Java]
-----------------
double initFreq = 1.0 / x.size();
focalDrv.x.fillWith(initFreq);
for (int i = 0; i < r.size(0); i++) {
	focalCnt.r.setByInt(random.nextDouble(), i);
	focalCnt.K.setByInt(5.0 + initFreq + random.nextDouble(), i);
	for (int j = 0; j < alpha.size(1); j++) {
		if (i == j)
			focalCnt.alpha.setByInt(1.0, i, j);
		else
			focalCnt.alpha.setByInt(max(0.0001, random.nextDouble()), i, j);
	}
}
-----------------


`function:InitDist`:

[source, Java]
-----------------
focalCnt.freq = 5 + random.nextInt(50);
focalCnt.inten = random.nextDouble()*100;
-----------------

`function:CommGrowth`:
[source, Java]
-----------------
// growth
double[] dxdt = new double[x.size(0)];
for (int i = 0; i < x.size(0); i++) {
	double sum = 0;
	for (int j = 0; j < alpha.size(1); j++)
		sum += alpha.getByInt(i, j) * x.getByInt(j);
	dxdt[i] = r.getByInt(i) * x.getByInt(i) * (1 - sum / K.getByInt(i));
}
for (int i = 0; i < dxdt.length; i++)
	focalDrv.x.setByInt(Math.max(x.getByInt(i) + dxdt[i] * dt, 0.0), i);

// compute diversity
double xtot = 0.0;
for (int i = 0; i < focalDrv.x.size(0); i++)
	xtot += focalDrv.x.getByInt(i);
focalDec.div = 0.0;
for (int i = 0; i < focalDrv.x.size(0); i++)
	if (focalDrv.x.getByInt(i) > 0.0)
		focalDec.div -= (focalDrv.x.getByInt(i) / xtot) * log(focalDrv.x.getByInt(i) / xtot);

-----------------

`function:DistOccurrence`:
[source, Java]
--------------------
double proba = 1.0 / freq;
if (random.nextDouble() < proba)
	return true;
else
	return false;

--------------------

`function:DistEffectsComm`:
[source, Java]
---------------------
for (int i = 0; i < x.size(); i++)
	if (x.getByInt(i) > K.getByInt(i) * inten / 100000.0)
		otherDrv.x.setByInt(otherDrv.x.getByInt(i) * K.getByInt(i) * inten / 100000.0, i);
---------------------


==== Next

The next tutorial introduces the event timer to drive disturbance.
