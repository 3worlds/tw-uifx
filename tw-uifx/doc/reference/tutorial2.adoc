=== Tutorial 2: Linking a _3Worlds_ project to a Integrated Development Environment (IDE)

==== Introduction 

The previous tutorial demonstrated how to insert Java code into the model specifications using snippets. In this tutorial we demonstrate another way: linking the project to an IDE and writing the code there. Generally, the only way to develop any but the simplest of models is to code in a professional IDE such as _Eclipse_, _Intellij_ or _NetBeans_. At the time of writing, linking specifications to a Java project has only be tested with the _Eclipse_ IDE.

==== New Java project

First create a Java project in _Eclipse_.

. In _Eclipse_, create an new Java project and name it `tut2` (first letter lowercase).

. Right-click on the new project and select  `properties -> Java Build Path`.

. Under the `Libraries` tab, highlight `Classpath` and  click the `Add External JARs...` button to the right.

. Navigate to the .3w directory and select `tw-dep.jar`.

. Click `Apply and close`.

This installs the _3Worlds_ dependencies for this java project.

==== Specifications
Now create a _3Worlds_ project using tutorial 1 as a starting point.

. From _ModelMaker_ main menu select `New -> Tutorials -> 1 Logistic` name it `Tut2`

. Right-click on the root node (`3worlds:Tut2`) and select `Collapse -> All`.

. Right-click again on the root node and select `Expand -> system:sys1` 

. Re-apply the layout (*L*).

. Delete `snippet:snpt1` and `snippet:snpt2`.

. Save (`Ctrl+s`)

Next link this project to the Java project created above.

. From the _ModelMaker_ main menu, select `Edit -> Java project -> Connect...`.

. Navigate to your _Eclipse_ workspace and select `tut2`.

. In the _Eclipse_ Project Explorer view, right-click on `tut2` and select `Refresh`.

. In the _Eclipse_ main menu, select `Project - > clean` and apply to `tut2`.

You may find a task message in _ModelMaker_ complaining about file dates. If so, click the *Compile* button in _ModelMaker_. You may also need to refresh and clean the Java project (in _Eclipse_).

==== Writing Java code 

In the `src` folder of `tut2`, you'll now find a new package called `code` and `code.sys1`. These have been generated by _ModelMaker_ upon linking. In the `code` package is a Java file with the same name as the 3Worlds project: `Tut2.java`. This single class is where you add all your code. The other classes in `code.sys1` are not intended to be edited. If you do edit these, your edits will be overwritten whenever _ModelMaker_ recompiles (i.e. whenever the specifications are edited). 

. Open `Tut2.java` in the _Eclipse_ editor.

Near the bottom of the file are two methods: `chaos` and `init1`, mapped from the names of the function and initFunction nodes we created in `Tut2` with _ModelMaker_. Within the body of these methods are a pair of insertion markers: 

- `insert Begin-- >`; and 
- `insert End---- <`.

. Add the following code between these markers, taking care to leave the text of the markers unchanged.

[source,Java]
-----------------
#// chaos ---- Code insert Begin-->
 	focalDrv.x = r*x*(1-x);
#// chaos ---- Code insert End----<
-----------------


[source,Java]
-----------------
#// init1 ---- Code insert Begin-->
	focalDrv.x = 0.001;
	focalLtc.r = 3.7;
#// init1 ---- Code insert End----<
-----------------

Because these two methods are mapped to this generated file from the specifications created in _ModelMaker_, it follows that changes to the specifications may result in changes to these methods. So the question arises, how does _ModelMaker_ manage this without losing the Java code you write?

If there have been changes to the number, name or type of `function` used in the specification, changes to anything in the `dataDefinition` sub-tree, or changes to the _roles_ of `components`, _ModelMaker_ will back up your old file as a text file with a unique name (e.g `\_Tut2_1.txt`,`_Tut2_2.txt` etc...) within the current java package. This way you can copy and paste you code back to the proper place. Otherwise _ModelMaker_ will never overwrite your code. 

When _ModelMaker_ searches for differences between previous and current versions of this Java file, it will ignore any comments and import statements. The key text that the system looks for are two code insertion markers. Therefore, although you can do as you please with the generated comments, you should take care not to alter the text of the markers themseleves. 

If the task list is empty, you can now execute the specifications by deploying from _ModelMaker_.

Running the simulation directly from _ModelMaker_ is a convenient way to speed up the turn-around time in developing and testing specifications. Once the specifications are stable, you can run _ModelRunner_ from a jar and debug your equations by running from the IDE.

===== Debugging your code

Once the specifications are valid (i.e no tasks in the task list) you can quit _ModelMaker_ and debug your code from the IDE.

In the default package of the linked java project (`tut2`) is a java file called `UserCodeRunner.java`. This was created the first time you linked the project made with _ModelMaker_ to the Java project. By placing breakpoints in the methods you added to `Tut2.java` above, you can debug by running from this `main` class. The correct args have already been provided.

==== Next

The next tutorial (Tutorial 3) will introduce the use of tables and some additional output `widgets` to add to a simulation.









